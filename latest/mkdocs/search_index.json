{
    "docs": [
        {
            "location": "/", 
            "text": "Devices.jl\n\n\nA \nJulia\n package for CAD of electronic devices, in particular superconducting devices operating at microwave frequencies.\n\n\n\n\nInstallation\n\n\n\n\nPkg.add(\"Clipper\")\n\n\n\n\nWhen Clipper.jl is added, it will be built to compile shared library / DLL files. A compiler will be downloaded for you on Windows.\n\n\n\n\nPkg.clone(\"https://github.com/PainterQubits/Devices.jl.git\")\n\n\n\n\n\n\nQuick start\n\n\nLet's mock up a transmission line with two launchers and some bridges across the transmission line. We begin by making a cell with a rectangle in it:\n\n\nusing\n \nDevices\n,\n \nDevices\n.\nPreferMicrons\n,\n \nFileIO\n\n\n\ncr\n \n=\n \nCell\n(\nrect\n,\n \nnm\n)\n\n\nr\n \n=\n \ncentered\n(\nRectangle\n(\n20\n\u03bcm\n,\n \n40\n\u03bcm\n))\n\n\nrender!\n(\ncr\n,\n \nr\n,\n \nRectangles\n.\nPlain\n(),\n \nGDSMeta\n(\n1\n,\n0\n))\n\n\n\n\n\n\n\n\nNote that when you use \nDevices.PreferMicrons\n, this will also enable the unqualified use of the following units: \npm\n, \nnm\n, \n\u03bcm\n, \nmm\n, \ncm\n, \ndm\n, \nm\n, \n\u00b0\n, \nrad\n. (By unqualified we mean that the symbols are imported into the calling namespace and do not need to be prefixed with a module name.) When adding length units together, if the units don't agree, the result will be in microns. You can \ninstead\n do \nusing\n \nDevices.PreferNanometers\n if you want the result to default to nanometers. (These are your two choices at the moment, though there's nothing fundamentally limiting other possibilities: see \nsrc/units.jl\n for how to do this for other units.)\n\n\nWhen you specify the units for a \nCell\n, you are specifying a database unit. Anything rendered into this cell will be discretized into integer multiples of the database unit. This means that nothing smaller than 1 nm can be represented accurately. Nonetheless, this is typically a satisfactory choice for superconducting devices.\n\n\nA rectangle made with a width and height parameter will default to having its lower-left corner at the origin. \ncentered\n will return a rectangle that is centered about the origin instead.\n\n\nThe rectangle is then rendered into the cell. \nRectangles.Plain()\n specifies a rendering style. Other examples include \nRectangles.Rounded\n (where the corners are rounded off) or \nRectangles.Undercut\n. You can omit the style, in which case \nRectangles.Plain()\n will be assumed. \nGDSMeta(1)\n indicates the target GDS-II layer. You can also specify the GDS-II datatype as a second argument, e.g. \nGDSMeta(1,0)\n.\n\n\nIn another cell, we make the transmission line with some launchers on both ends:\n\n\np\n \n=\n \nPath\n(\n\u03bcm\n)\n\n\nsty\n \n=\n \nlaunch!\n(\np\n)\n\n\nstraight!\n(\np\n,\n \n500\n\u03bcm\n,\n \nsty\n)\n\n\nturn!\n(\np\n,\n \n\u03c0\n/\n2\n,\n \n150\n\u03bcm\n)\n\n\nstraight!\n(\np\n,\n \n500\n\u03bcm\n)\n\n\nlaunch!\n(\np\n)\n\n\ncp\n \n=\n \nCell\n(\npathonly\n,\n \nnm\n)\n\n\nrender!\n(\ncp\n,\n \np\n,\n \nGDSMeta\n(\n0\n))\n\n\n\n\n\n\n\n\nFinally, let's put bridges across the feedline:\n\n\nturnidx\n \n=\n \nInt\n((\nlength\n(\np\n)\n+\n1\n)\n/\n2\n)\n \n-\n \n1\n \n# the first straight segment of the path\n\n\nsimplify!\n(\np\n,\n \nturnidx\n+\n(\n0\n:\n2\n))\n\n\nattach!\n(\np\n,\n \nCellReference\n(\ncr\n,\n \nPoint\n(\n0.0\n\u03bcm\n,\n \n0.0\n\u03bcm\n)),\n \n(\n40\n\u03bcm\n)\n:\n(\n40\n\u03bcm\n)\n:\n((\npathlength\n(\np\n[\nturnidx\n]))\n-\n40\n\u03bcm\n),\n \ni\n=\nturnidx\n)\n\n\nc\n \n=\n \nCell\n(\ndecoratedpath\n,\n \nnm\n)\n\n\nrender!\n(\nc\n,\n \np\n,\n \nGDSMeta\n(\n0\n))\n\n\n\n\n\n\n\n\nHow easy was that?\n\n\nYou can save a GDS file for e-beam lithography, or an SVG for vector graphics by using \nsave\n with an appropriate extension:\n\n\nsave\n(\n/path/to/myoutput.gds\n,\n \nc\n)\n\n\nsave\n(\n/path/to/myoutput.svg\n,\n \nc\n)\n\n\n\n\n\n\nNote that SVG support is experimental at the moment, and is not completely optimized. It is however used in generating the graphics you see in this documentation. If you use Juno for Atom, rendered cells are automatically previewed in the plot pane provided you enter \nDevices.@junographics\n at the start of your session. If you use Jupyter/IJulia, rendered cells are automatically returned as a result\n\n\n\n\nExample without using units\n\n\nFor compatibility and laziness reasons it is possible to use Devices.jl without units at all. \nIf you do not provide units, all values are presumed to be in microns.\n The syntax is otherwise the same:\n\n\nusing\n \nDevices\n,\n \nFileIO\n\n\n\ncr\n \n=\n \nCell\n(\nrect\n)\n\n\nr\n \n=\n \ncentered\n(\nRectangle\n(\n20\n,\n40\n))\n\n\nrender!\n(\ncr\n,\n \nr\n,\n \nGDSMeta\n(\n1\n))\n\n\n\np\n \n=\n \nPath\n()\n\n\nsty\n \n=\n \nlaunch!\n(\np\n)\n\n\nstraight!\n(\np\n,\n500\n,\nsty\n)\n\n\nturn!\n(\np\n,\n\u03c0\n/\n2\n,\n150\n)\n\n\nstraight!\n(\np\n,\n500\n)\n\n\nlaunch!\n(\np\n)\n\n\ncp\n \n=\n \nCell\n(\npathonly\n)\n\n\nrender!\n(\ncp\n,\n \np\n,\n \nGDSMeta\n(\n0\n))\n\n\n\nturnidx\n \n=\n \nInt\n((\nlength\n(\np\n)\n+\n1\n)\n/\n2\n)\n \n-\n \n1\n \n# the first straight segment of the path\n\n\nsimplify!\n(\np\n,\n \nturnidx\n+\n(\n0\n:\n2\n))\n\n\nattach!\n(\np\n,\n \nCellReference\n(\ncr\n,\n \nPoint\n(\n0.0\n,\n0.0\n)),\n \n40\n:\n40\n:\n((\npathlength\n(\np\n[\nturnidx\n]))\n-\n40\n),\n \ni\n=\nturnidx\n)\n\n\nc\n \n=\n \nCell\n(\ndecoratedpath\n)\n\n\nrender!\n(\nc\n,\n \np\n,\n \nGDSMeta\n(\n0\n))\n\n\n\n\n\n\nSome caveats:\n\n\n\n\nYou cannot mix and match unitful and unitless numbers (the latter are not presumed to be in microns in this case).\n\n\nIt is somewhat annoying to maintain this behavior alongside unit support, so eventually I may drop support for this and require the use of units.\n\n\n\n\n\n\nPerformance tips\n\n\nSince Julia has a just-in-time compiler, the first time code is executed may take much longer than any other times. This means that a lot of time will be wasted repeating compilations if you run Devices.jl in a script like you would in other languages. For readability, it is best to split up your CAD code into functions that have clearly named inputs and perform a well-defined task. At present, for performance reasons, it is also best to avoid writing functions with keyword arguments (though this will be addressed in Julia 1.0).\n\n\nIt is also best to avoid writing statements in global scope. In other words, put most of your code in a function. Your CAD script should ideally look like the following:\n\n\nusing\n \nDevices\n,\n \nDevices\n.\nPreferMicrons\n,\n \nFileIO\n\n\nusing\n \nCoordinateTransformations\n\n\nusing\n \nClipper\n\n\n\nfunction\n \nsubroutine1\n()\n\n    \n# render some thing\n\n\nend\n\n\n\nfunction\n \nsubroutine2\n()\n\n    \n# render some other thing\n\n\nend\n\n\n\nfunction\n \nmain\n()\n\n    \n# my cad code goes here: do all of the things\n\n    \nsubroutine1\n()\n\n    \nsubroutine2\n()\n\n    \nsave\n(\n/path/to/out.gds\n,\n \n...\n)\n\n\nend\n\n\n\nmain\n()\n \n# execute main() at end of script.\n\n\n\n\n\n\nYou can then \ninclude\n this file from Julia to generate your pattern. Provided you write your script this way, subsequent runs should be several times faster than the first if you \ninclude\n the file again from the same Julia session.\n\n\n\n\nTroubleshooting\n\n\n\n\nIf you cannot save the GDS file, try deleting any file that happens to be at the target path. A corrupted file at the target path may prevent saving.\n\n\nDecorated styles should not become part of compound styles, for now. Avoid this by decorating / attaching cell references at the end.", 
            "title": "Home"
        }, 
        {
            "location": "/#devicesjl", 
            "text": "A  Julia  package for CAD of electronic devices, in particular superconducting devices operating at microwave frequencies.", 
            "title": "Devices.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Pkg.add(\"Clipper\")   When Clipper.jl is added, it will be built to compile shared library / DLL files. A compiler will be downloaded for you on Windows.   Pkg.clone(\"https://github.com/PainterQubits/Devices.jl.git\")", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Let's mock up a transmission line with two launchers and some bridges across the transmission line. We begin by making a cell with a rectangle in it:  using   Devices ,   Devices . PreferMicrons ,   FileIO  cr   =   Cell ( rect ,   nm )  r   =   centered ( Rectangle ( 20 \u03bcm ,   40 \u03bcm ))  render! ( cr ,   r ,   Rectangles . Plain (),   GDSMeta ( 1 , 0 ))    Note that when you use  Devices.PreferMicrons , this will also enable the unqualified use of the following units:  pm ,  nm ,  \u03bcm ,  mm ,  cm ,  dm ,  m ,  \u00b0 ,  rad . (By unqualified we mean that the symbols are imported into the calling namespace and do not need to be prefixed with a module name.) When adding length units together, if the units don't agree, the result will be in microns. You can  instead  do  using   Devices.PreferNanometers  if you want the result to default to nanometers. (These are your two choices at the moment, though there's nothing fundamentally limiting other possibilities: see  src/units.jl  for how to do this for other units.)  When you specify the units for a  Cell , you are specifying a database unit. Anything rendered into this cell will be discretized into integer multiples of the database unit. This means that nothing smaller than 1 nm can be represented accurately. Nonetheless, this is typically a satisfactory choice for superconducting devices.  A rectangle made with a width and height parameter will default to having its lower-left corner at the origin.  centered  will return a rectangle that is centered about the origin instead.  The rectangle is then rendered into the cell.  Rectangles.Plain()  specifies a rendering style. Other examples include  Rectangles.Rounded  (where the corners are rounded off) or  Rectangles.Undercut . You can omit the style, in which case  Rectangles.Plain()  will be assumed.  GDSMeta(1)  indicates the target GDS-II layer. You can also specify the GDS-II datatype as a second argument, e.g.  GDSMeta(1,0) .  In another cell, we make the transmission line with some launchers on both ends:  p   =   Path ( \u03bcm )  sty   =   launch! ( p )  straight! ( p ,   500 \u03bcm ,   sty )  turn! ( p ,   \u03c0 / 2 ,   150 \u03bcm )  straight! ( p ,   500 \u03bcm )  launch! ( p )  cp   =   Cell ( pathonly ,   nm )  render! ( cp ,   p ,   GDSMeta ( 0 ))    Finally, let's put bridges across the feedline:  turnidx   =   Int (( length ( p ) + 1 ) / 2 )   -   1   # the first straight segment of the path  simplify! ( p ,   turnidx + ( 0 : 2 ))  attach! ( p ,   CellReference ( cr ,   Point ( 0.0 \u03bcm ,   0.0 \u03bcm )),   ( 40 \u03bcm ) : ( 40 \u03bcm ) : (( pathlength ( p [ turnidx ])) - 40 \u03bcm ),   i = turnidx )  c   =   Cell ( decoratedpath ,   nm )  render! ( c ,   p ,   GDSMeta ( 0 ))    How easy was that?  You can save a GDS file for e-beam lithography, or an SVG for vector graphics by using  save  with an appropriate extension:  save ( /path/to/myoutput.gds ,   c )  save ( /path/to/myoutput.svg ,   c )   Note that SVG support is experimental at the moment, and is not completely optimized. It is however used in generating the graphics you see in this documentation. If you use Juno for Atom, rendered cells are automatically previewed in the plot pane provided you enter  Devices.@junographics  at the start of your session. If you use Jupyter/IJulia, rendered cells are automatically returned as a result", 
            "title": "Quick start"
        }, 
        {
            "location": "/#example-without-using-units", 
            "text": "For compatibility and laziness reasons it is possible to use Devices.jl without units at all.  If you do not provide units, all values are presumed to be in microns.  The syntax is otherwise the same:  using   Devices ,   FileIO  cr   =   Cell ( rect )  r   =   centered ( Rectangle ( 20 , 40 ))  render! ( cr ,   r ,   GDSMeta ( 1 ))  p   =   Path ()  sty   =   launch! ( p )  straight! ( p , 500 , sty )  turn! ( p , \u03c0 / 2 , 150 )  straight! ( p , 500 )  launch! ( p )  cp   =   Cell ( pathonly )  render! ( cp ,   p ,   GDSMeta ( 0 ))  turnidx   =   Int (( length ( p ) + 1 ) / 2 )   -   1   # the first straight segment of the path  simplify! ( p ,   turnidx + ( 0 : 2 ))  attach! ( p ,   CellReference ( cr ,   Point ( 0.0 , 0.0 )),   40 : 40 : (( pathlength ( p [ turnidx ])) - 40 ),   i = turnidx )  c   =   Cell ( decoratedpath )  render! ( c ,   p ,   GDSMeta ( 0 ))   Some caveats:   You cannot mix and match unitful and unitless numbers (the latter are not presumed to be in microns in this case).  It is somewhat annoying to maintain this behavior alongside unit support, so eventually I may drop support for this and require the use of units.", 
            "title": "Example without using units"
        }, 
        {
            "location": "/#performance-tips", 
            "text": "Since Julia has a just-in-time compiler, the first time code is executed may take much longer than any other times. This means that a lot of time will be wasted repeating compilations if you run Devices.jl in a script like you would in other languages. For readability, it is best to split up your CAD code into functions that have clearly named inputs and perform a well-defined task. At present, for performance reasons, it is also best to avoid writing functions with keyword arguments (though this will be addressed in Julia 1.0).  It is also best to avoid writing statements in global scope. In other words, put most of your code in a function. Your CAD script should ideally look like the following:  using   Devices ,   Devices . PreferMicrons ,   FileIO  using   CoordinateTransformations  using   Clipper  function   subroutine1 () \n     # render some thing  end  function   subroutine2 () \n     # render some other thing  end  function   main () \n     # my cad code goes here: do all of the things \n     subroutine1 () \n     subroutine2 () \n     save ( /path/to/out.gds ,   ... )  end  main ()   # execute main() at end of script.   You can then  include  this file from Julia to generate your pattern. Provided you write your script this way, subsequent runs should be several times faster than the first if you  include  the file again from the same Julia session.", 
            "title": "Performance tips"
        }, 
        {
            "location": "/#troubleshooting", 
            "text": "If you cannot save the GDS file, try deleting any file that happens to be at the target path. A corrupted file at the target path may prevent saving.  Decorated styles should not become part of compound styles, for now. Avoid this by decorating / attaching cell references at the end.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/points/", 
            "text": "Points live in a Cartesian coordinate system with \nReal\n or \nUnitful.Length\n coordinates:\n\n\njulia\n Point(1,1)\n2-element Devices.Points.Point{Int64}:\n 1\n 1\n\njulia\n Point(1.0,1.0)\n2-element Devices.Points.Point{Float64}:\n 1.0\n 1.0\n\njulia\n Point(1.0u\n\u03bcm\n, 1.0u\n\u03bcm\n)\n2-element Devices.Points.Point{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{\u03bcm}}}:\n 1.0 \u03bcm\n 1.0 \u03bcm\n\n\n\n\n\nIf a point has \nReal\n coordinates, the absence of a unit is interpreted to mean \n\u03bcm\n whenever the geometry is saved to a GDS format, but until then it is just considered to be a pure number. Therefore you cannot mix and match \nReal\n and \nLength\n coordinates:\n\n\njulia\n Point(1.0u\n\u03bcm\n, 1.0)\nERROR: Cannot use `Point` with this combination of types.\n\n\n\n\n\nYou can add Points together or scale them:\n\n\njulia\n 3*Point(1,1)+Point(1,2)\n2-element Devices.Points.Point{Int64}:\n 4\n 5\n\n\n\n\n\nYou can also do affine transformations by composing any number of \nTranslation\n and \nRotation\ns, which will return a callable object representing the transformation. You can type the following Unicode symbols with \n\\degree\n and \n\\circ\n tab-completions in the Julia REPL or using the Atom package \nlatex-completions\n.\n\n\njulia\n aff = Rotation(90\u00b0) \u2218 Translation(Point(1,2))\nAffineMap([0.0 -1.0; 1.0 0.0], (-2.0,1.0))\n\njulia\n aff(Point(0,0))\n2-element Devices.Points.Point{Float64}:\n -2.0\n  1.0\n\n\n\n\n\n\n\nAPI\n\n\n#\n\n\nDevices.PointTypes\n \n \nConstant\n.\n\n\nPointTypes = Union{Real, DimensionlessQuantity, Length, InverseLength}\n\n\n\n\n\nAllowed type variables for \nPoint{T}\n types.\n\n\nsource\n\n\n#\n\n\nDevices.Coordinate\n \n \nConstant\n.\n\n\nCoordinate = Union{Real, Length}\n\n\n\n\n\nType alias for numeric types suitable for coordinate systems.\n\n\nsource\n\n\n#\n\n\nDevices.Points.Point\n \n \nType\n.\n\n\nstruct Point{T} \n: StaticArrays.FieldVector{2,T}\n    x::T\n    y::T\nend\n\n\n\n\n\n2D Cartesian coordinate in the plane.\n\n\nsource\n\n\n#\n\n\nDevices.Points.getx\n \n \nFunction\n.\n\n\ngetx(p::Point)\n\n\n\n\n\nGet the x-coordinate of a point. You can also use \np.x\n or \np[1]\n.\n\n\nsource\n\n\n#\n\n\nDevices.Points.gety\n \n \nFunction\n.\n\n\ngety(p::Point)\n\n\n\n\n\nGet the y-coordinate of a point. You can also use \np.y\n or \np[2]\n.\n\n\nsource\n\n\n#\n\n\nDevices.lowerleft\n \n \nFunction\n.\n\n\nlowerleft{T}(A::AbstractArray{Point{T}})\n\n\n\n\n\nReturns the lower-left \nPoint\n of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in \nA\n.\n\n\nExample:\n\n\njulia\n lowerleft([Point(2,0),Point(1,1),Point(0,2),Point(-1,3)])\n2-element Devices.Points.Point{Int64}:\n -1\n  0\n\n\n\n\n\nsource\n\n\nlowerleft(r::Rectangle)\n\n\n\n\n\nReturns the lower-left corner of a rectangle (Point object).\n\n\nsource\n\n\nlowerleft(x::Polygon)\n\n\n\n\n\nReturn the lower-left-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nsource\n\n\n#\n\n\nDevices.upperright\n \n \nFunction\n.\n\n\nupperright{T}(A::AbstractArray{Point{T}})\n\n\n\n\n\nReturns the upper-right \nPoint\n of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in \nA\n.\n\n\nExample:\n\n\njulia\n upperright([Point(2,0),Point(1,1),Point(0,2),Point(-1,3)])\n2-element Devices.Points.Point{Int64}:\n 2\n 3\n\n\n\n\n\nsource\n\n\nupperright(r::Rectangle)\n\n\n\n\n\nReturns the upper-right corner of a rectangle (Point object).\n\n\nsource\n\n\nupperright(x::Polygon)\n\n\n\n\n\nReturn the upper-right-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nsource\n\n\n\n\nImplementation details\n\n\nPoints are implemented using the abstract type \nFieldVector\n from \nStaticArrays.jl\n. This permits a fast, efficient representation of coordinates in the plane. Additionally, unlike \nTuple\n objects, we can add points together, simplifying many function definitions.", 
            "title": "Points"
        }, 
        {
            "location": "/points/#api", 
            "text": "#  Devices.PointTypes     Constant .  PointTypes = Union{Real, DimensionlessQuantity, Length, InverseLength}  Allowed type variables for  Point{T}  types.  source  #  Devices.Coordinate     Constant .  Coordinate = Union{Real, Length}  Type alias for numeric types suitable for coordinate systems.  source  #  Devices.Points.Point     Type .  struct Point{T}  : StaticArrays.FieldVector{2,T}\n    x::T\n    y::T\nend  2D Cartesian coordinate in the plane.  source  #  Devices.Points.getx     Function .  getx(p::Point)  Get the x-coordinate of a point. You can also use  p.x  or  p[1] .  source  #  Devices.Points.gety     Function .  gety(p::Point)  Get the y-coordinate of a point. You can also use  p.y  or  p[2] .  source  #  Devices.lowerleft     Function .  lowerleft{T}(A::AbstractArray{Point{T}})  Returns the lower-left  Point  of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in  A .  Example:  julia  lowerleft([Point(2,0),Point(1,1),Point(0,2),Point(-1,3)])\n2-element Devices.Points.Point{Int64}:\n -1\n  0  source  lowerleft(r::Rectangle)  Returns the lower-left corner of a rectangle (Point object).  source  lowerleft(x::Polygon)  Return the lower-left-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  source  #  Devices.upperright     Function .  upperright{T}(A::AbstractArray{Point{T}})  Returns the upper-right  Point  of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in  A .  Example:  julia  upperright([Point(2,0),Point(1,1),Point(0,2),Point(-1,3)])\n2-element Devices.Points.Point{Int64}:\n 2\n 3  source  upperright(r::Rectangle)  Returns the upper-right corner of a rectangle (Point object).  source  upperright(x::Polygon)  Return the upper-right-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  source", 
            "title": "API"
        }, 
        {
            "location": "/points/#implementation-details", 
            "text": "Points are implemented using the abstract type  FieldVector  from  StaticArrays.jl . This permits a fast, efficient representation of coordinates in the plane. Additionally, unlike  Tuple  objects, we can add points together, simplifying many function definitions.", 
            "title": "Implementation details"
        }, 
        {
            "location": "/polygons/", 
            "text": "Abstract polygons\n\n\nIn this package, any polygon regardless of its concrete representation in memory should be a subtype of \nDevices.AbstractPolygon\n.\n\n\n#\n\n\nDevices.AbstractPolygon\n \n \nType\n.\n\n\nabstract type AbstractPolygon{T\n:Coordinate} end\n\n\n\n\n\nAnything you could call a polygon regardless of the underlying representation. Currently only \nRectangle\n or \nPolygon\n are concrete subtypes, but one could imagine further subtypes to represent specific shapes that appear in highly optimized pattern formats. Examples include the OASIS format (which has 25 implementations of trapezoids) or e-beam lithography pattern files like the Raith GPF format.\n\n\nsource\n\n\n\n\nAffine transformations\n\n\nThe mechanism for affine transformations is largely provided by the \nCoordinateTransformations.jl\n package. For convenience, the documentation for \nTranslation\n and \ncompose\n is reproduced below from that package. We implement our own 2D rotations.\n\n\nAn example of how to use affine transformations with polygons:\n\n\njulia\n r = Rectangle(1,1)\nDevices.Rectangles.Rectangle{Int64}((0,0), (1,1))\n\njulia\n trans = Translation(10,10)\nTranslation(10, 10)\n\njulia\n trans = Rotation(90\u00b0) \u2218 trans\nAffineMap([0.0 -1.0; 1.0 0.0], [-10.0, 10.0])\n\njulia\n trans(r)\nDevices.Polygons.Polygon{Float64}(Devices.Points.Point{Float64}[(-10.0,10.0), (-10.0,11.0), (-11.0,11.0), (-11.0,10.0)])\n\n\n\n\n\n#\n\n\nCoordinateTransformations.compose\n \n \nFunction\n.\n\n\ncompose(trans1, trans2)\ntrans1 \u2218 trans2\n\n\n\n\n\nTake two transformations and create a new transformation that is equivalent to successively applying \ntrans2\n to the coordinate, and then \ntrans1\n. By default will create a \nComposedTransformation\n, however this method can be overloaded for efficiency (e.g. two affine transformations naturally compose to a single affine transformation).\n\n\nsource\n\n\n#\n\n\nDevices.Points.Rotation\n \n \nFunction\n.\n\n\nRotation(\u0398)\n\n\n\n\n\nConstruct a rotation about the origin. Units accepted (no units \u21d2 radians).\n\n\nsource\n\n\n#\n\n\nCoordinateTransformations.Translation\n \n \nType\n.\n\n\nTranslation(v) \n: AbstractAffineMap\nTranslation(dx, dy)       (2D)\nTranslation(dx, dy, dz)   (3D)\n\n\n\n\n\nConstruct the \nTranslation\n transformation for translating Cartesian points by an offset \nv = (dx, dy, ...)\n\n\nsource\n\n\n#\n\n\nDevices.Points.XReflection\n \n \nFunction\n.\n\n\nXReflection()\n\n\n\n\n\nConstruct a reflection about the x-axis (y-coordinate changes sign).\n\n\nExample:\n\n\njulia\n trans = XReflection()\nLinearMap([1 0; 0 -1])\n\njulia\n trans(Point(1,1))\n2-element Devices.Points.Point{Int64}:\n  1\n -1\n\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Points.YReflection\n \n \nFunction\n.\n\n\nYReflection()\n\n\n\n\n\nConstruct a reflection about the y-axis (x-coordinate changes sign).\n\n\nExample:\n\n\njulia\n trans = YReflection()\nLinearMap([-1 0; 0 1])\n\njulia\n trans(Point(1,1))\n2-element Devices.Points.Point{Int64}:\n -1\n  1\n\n\n\n\n\nsource\n\n\n\n\nClipping\n\n\n#\n\n\nDevices.Polygons.clip\n \n \nFunction\n.\n\n\nclip\n(\nop\n::\nClipper\n.\nClipType\n,\n \ns\n::\nAbstractPolygon\n{\nS\n}\n,\n \nc\n::\nAbstractPolygon\n{\nT\n}\n;\n\n    \npfs\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n,\n\n    \npfc\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n)\n \nwhere\n\n    \n{\nS\n \n:\n \nCoordinate,T\n \n:\n \nCoordinate\n}\n\n\nclip\n(\nop\n::\nClipper\n.\nClipType\n,\n \ns\n::\nAbstractVector\n{\nA\n}\n,\n \nc\n::\nAbstractVector\n{\nB\n}\n;\n\n    \npfs\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n,\n\n    \npfc\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n)\n \nwhere\n\n    \n{\nS,\n \nT,\n \nA\n \n:\n \nAbstractPolygon{S\n}\n,\n \nB\n \n:\n \nAbstractPolygon\n{\nT\n}\n}\n\n\nclip\n{\nS\n:AbstractPolygon,\n \nT\n:AbstractPolygon\n}\n(\nop\n::\nClipper\n.\nClipType\n,\n\n    \ns\n::\nAbstractVector\n{\nS\n}\n,\n \nc\n::\nAbstractVector\n{\nT\n}\n;\n\n    \npfs\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n,\n\n    \npfc\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n)\n\n\n\n\n\n\nUsing the \nClipper\n library and the \nClipper.jl\n wrapper, perform polygon clipping. The first argument must be one of the following types :\n\n\n\n\nClipper.ClipTypeDifference\n\n\nClipper.ClipTypeIntersection\n\n\nClipper.ClipTypeUnion\n\n\nClipper.ClipTypeXor\n\n\n\n\nNote that these are types; you should not follow them with \n()\n. The second and third arguments are \nAbstractPolygon\n objects. Keyword arguments \npfs\n and \npfc\n specify polygon fill rules (see the \nClipper\n docs\n for further information). These arguments may include:\n\n\n\n\nClipper.PolyFillTypeNegative\n\n\nClipper.PolyFillTypePositive\n\n\nClipper.PolyFillTypeEvenOdd\n\n\nClipper.PolyFillTypeNonZero\n\n\n\n\nsource\n\n\n\n\nOffsetting\n\n\n#\n\n\nDevices.Polygons.offset\n \n \nFunction\n.\n\n\noffset\n{\nS\n:Coordinate\n}\n(\ns\n::\nAbstractPolygon\n{\nS\n}\n,\n \ndelta\n::\nCoordinate\n;\n\n    \nj\n::\nClipper\n.\nJoinType\n=\nClipper\n.\nJoinTypeMiter\n,\n\n    \ne\n::\nClipper\n.\nEndType\n=\nClipper\n.\nEndTypeClosedPolygon\n)\n\n\noffset\n{\nS\n:AbstractPolygon\n}\n(\nsubject\n::\nAbstractVector\n{\nS\n}\n,\n \ndelta\n::\nCoordinate\n;\n\n    \nj\n::\nClipper\n.\nJoinType\n=\nClipper\n.\nJoinTypeMiter\n,\n\n    \ne\n::\nClipper\n.\nEndType\n=\nClipper\n.\nEndTypeClosedPolygon\n)\n\n\noffset\n{\nS\n:Polygon\n}\n(\ns\n::\nAbstractVector\n{\nS\n}\n,\n \ndelta\n::\nCoordinate\n;\n\n    \nj\n::\nClipper\n.\nJoinType\n=\nClipper\n.\nJoinTypeMiter\n,\n\n    \ne\n::\nClipper\n.\nEndType\n=\nClipper\n.\nEndTypeClosedPolygon\n)\n\n\n\n\n\n\nUsing the \nClipper\n library and the \nClipper.jl\n wrapper, perform polygon offsetting.\n\n\nThe first argument should be an \nAbstractPolygon\n. The second argument is how much to offset the polygon. Keyword arguments include a \njoin type\n:\n\n\n\n\nClipper.JoinTypeMiter\n\n\nClipper.JoinTypeRound\n\n\nClipper.JoinTypeSquare\n\n\n\n\nand also an \nend type\n:\n\n\n\n\nClipper.EndTypeClosedPolygon\n\n\nClipper.EndTypeClosedLine\n\n\nClipper.EndTypeOpenSquare\n\n\nClipper.EndTypeOpenRound\n\n\nClipper.EndTypeOpenButt\n\n\n\n\nsource\n\n\n\n\nRectangle API\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nType\n.\n\n\nstruct Rectangle{T} \n: AbstractPolygon{T}\n    ll::Point{T}\n    ur::Point{T}\n    function Rectangle(a,b)\n        # Ensure ll is lower-left, ur is upper-right.\n        ll = Point(a.\n=b) .* a + Point(b.\n=a) .* b\n        ur = Point(a.\n=b) .* b + Point(b.\n=a) .* a\n        new(ll,ur)\n    end\nend\n\n\n\n\n\nA rectangle, defined by opposing lower-left and upper-right corner coordinates. Lower-left and upper-right are guaranteed to be such by the inner constructor.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\nRectangle(ll::Point, ur::Point)\n\n\n\n\n\nConvenience constructor for \nRectangle\n objects.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\nRectangle(width, height)\n\n\n\n\n\nConstructs \nRectangle\n objects by specifying the width and height rather than the lower-left and upper-right corners.\n\n\nThe rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of \nRectangle{Int}\n type, this would not be possible if either \nwidth\n or \nheight\n were odd numbers. This definition ensures type stability in the constructor.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(r::Rectangle)\n\n\n\n\n\nNo-op (just returns \nr\n).\n\n\nsource\n\n\n#\n\n\nDevices.center\n \n \nMethod\n.\n\n\ncenter(r::Rectangle)\n\n\n\n\n\nReturns a \nPoint\n corresponding to the center of the rectangle.\n\n\nsource\n\n\n#\n\n\nDevices.centered\n \n \nMethod\n.\n\n\ncentered(r::Rectangle)\n\n\n\n\n\nCenters a copy of \nr\n, with promoted coordinates if necessary. This function will not throw an \nInexactError()\n, even if \nr\n had integer coordinates.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.height\n \n \nMethod\n.\n\n\nheight(r::Rectangle)\n\n\n\n\n\nReturn the height of a rectangle.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.isproper\n \n \nMethod\n.\n\n\nisproper(r::Rectangle)\n\n\n\n\n\nReturns \ntrue\n if the rectangle has a non-zero size. Otherwise, returns \nfalse\n. Note that the upper-right and lower-left corners are enforced to be the \nur\n and \nll\n fields of a \nRectangle\n by the inner constructor.\n\n\nsource\n\n\n#\n\n\nDevices.lowerleft\n \n \nMethod\n.\n\n\nlowerleft(r::Rectangle)\n\n\n\n\n\nReturns the lower-left corner of a rectangle (Point object).\n\n\nsource\n\n\n#\n\n\nDevices.upperright\n \n \nMethod\n.\n\n\nupperright(r::Rectangle)\n\n\n\n\n\nReturns the upper-right corner of a rectangle (Point object).\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.points\n \n \nMethod\n.\n\n\npoints{T}(x::Rectangle{T})\n\n\n\n\n\nReturns the array of \nPoint\n objects defining the rectangle.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.width\n \n \nMethod\n.\n\n\nwidth(r::Rectangle)\n\n\n\n\n\nReturn the width of a rectangle.\n\n\nsource\n\n\n#\n\n\nBase.:+\n \n \nMethod\n.\n\n\n+(r::Rectangle, p::Point)\n\n\n\n\n\nTranslate a rectangle by \np\n.\n\n\nsource\n\n\n\n\nPolygon API\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nType\n.\n\n\nstruct Polygon{T} \n: AbstractPolygon{T}\n    p::Vector{Point{T}}\n    Polygon(x) = new(x)\n    Polygon(x::AbstractPolygon) = convert(Polygon{T}, x)\nend\n\n\n\n\n\nPolygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\nPolygon{T}(parr::AbstractVector{Point{T}})\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\nPolygon(p0::Point, p1::Point, p2::Point, p3::Point...)\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(p::Polygon)\n\n\n\n\n\nReturn a bounding Rectangle for polygon \np\n.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds{T\n:AbstractPolygon}(parr::AbstractArray{T})\n\n\n\n\n\nReturn a bounding \nRectangle\n for an array \nparr\n of \nAbstractPolygon\n objects.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\n\n\n\nReturn a bounding \nRectangle\n for several \nAbstractPolygon\n objects.\n\n\nsource\n\n\n#\n\n\nDevices.lowerleft\n \n \nMethod\n.\n\n\nlowerleft(x::Polygon)\n\n\n\n\n\nReturn the lower-left-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nsource\n\n\n#\n\n\nDevices.upperright\n \n \nMethod\n.\n\n\nupperright(x::Polygon)\n\n\n\n\n\nReturn the upper-right-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.points\n \n \nMethod\n.\n\n\npoints(x::Polygon)\n\n\n\n\n\nReturns the array of \nPoint\n objects defining the polygon.\n\n\nsource", 
            "title": "Polygons"
        }, 
        {
            "location": "/polygons/#abstract-polygons", 
            "text": "In this package, any polygon regardless of its concrete representation in memory should be a subtype of  Devices.AbstractPolygon .  #  Devices.AbstractPolygon     Type .  abstract type AbstractPolygon{T :Coordinate} end  Anything you could call a polygon regardless of the underlying representation. Currently only  Rectangle  or  Polygon  are concrete subtypes, but one could imagine further subtypes to represent specific shapes that appear in highly optimized pattern formats. Examples include the OASIS format (which has 25 implementations of trapezoids) or e-beam lithography pattern files like the Raith GPF format.  source", 
            "title": "Abstract polygons"
        }, 
        {
            "location": "/polygons/#affine-transformations", 
            "text": "The mechanism for affine transformations is largely provided by the  CoordinateTransformations.jl  package. For convenience, the documentation for  Translation  and  compose  is reproduced below from that package. We implement our own 2D rotations.  An example of how to use affine transformations with polygons:  julia  r = Rectangle(1,1)\nDevices.Rectangles.Rectangle{Int64}((0,0), (1,1))\n\njulia  trans = Translation(10,10)\nTranslation(10, 10)\n\njulia  trans = Rotation(90\u00b0) \u2218 trans\nAffineMap([0.0 -1.0; 1.0 0.0], [-10.0, 10.0])\n\njulia  trans(r)\nDevices.Polygons.Polygon{Float64}(Devices.Points.Point{Float64}[(-10.0,10.0), (-10.0,11.0), (-11.0,11.0), (-11.0,10.0)])  #  CoordinateTransformations.compose     Function .  compose(trans1, trans2)\ntrans1 \u2218 trans2  Take two transformations and create a new transformation that is equivalent to successively applying  trans2  to the coordinate, and then  trans1 . By default will create a  ComposedTransformation , however this method can be overloaded for efficiency (e.g. two affine transformations naturally compose to a single affine transformation).  source  #  Devices.Points.Rotation     Function .  Rotation(\u0398)  Construct a rotation about the origin. Units accepted (no units \u21d2 radians).  source  #  CoordinateTransformations.Translation     Type .  Translation(v)  : AbstractAffineMap\nTranslation(dx, dy)       (2D)\nTranslation(dx, dy, dz)   (3D)  Construct the  Translation  transformation for translating Cartesian points by an offset  v = (dx, dy, ...)  source  #  Devices.Points.XReflection     Function .  XReflection()  Construct a reflection about the x-axis (y-coordinate changes sign).  Example:  julia  trans = XReflection()\nLinearMap([1 0; 0 -1])\n\njulia  trans(Point(1,1))\n2-element Devices.Points.Point{Int64}:\n  1\n -1  source  #  Devices.Points.YReflection     Function .  YReflection()  Construct a reflection about the y-axis (x-coordinate changes sign).  Example:  julia  trans = YReflection()\nLinearMap([-1 0; 0 1])\n\njulia  trans(Point(1,1))\n2-element Devices.Points.Point{Int64}:\n -1\n  1  source", 
            "title": "Affine transformations"
        }, 
        {
            "location": "/polygons/#clipping", 
            "text": "#  Devices.Polygons.clip     Function .  clip ( op :: Clipper . ClipType ,   s :: AbstractPolygon { S } ,   c :: AbstractPolygon { T } ; \n     pfs :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd , \n     pfc :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd )   where \n     { S   :   Coordinate,T   :   Coordinate }  clip ( op :: Clipper . ClipType ,   s :: AbstractVector { A } ,   c :: AbstractVector { B } ; \n     pfs :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd , \n     pfc :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd )   where \n     { S,   T,   A   :   AbstractPolygon{S } ,   B   :   AbstractPolygon { T } }  clip { S :AbstractPolygon,   T :AbstractPolygon } ( op :: Clipper . ClipType , \n     s :: AbstractVector { S } ,   c :: AbstractVector { T } ; \n     pfs :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd , \n     pfc :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd )   Using the  Clipper  library and the  Clipper.jl  wrapper, perform polygon clipping. The first argument must be one of the following types :   Clipper.ClipTypeDifference  Clipper.ClipTypeIntersection  Clipper.ClipTypeUnion  Clipper.ClipTypeXor   Note that these are types; you should not follow them with  () . The second and third arguments are  AbstractPolygon  objects. Keyword arguments  pfs  and  pfc  specify polygon fill rules (see the  Clipper  docs  for further information). These arguments may include:   Clipper.PolyFillTypeNegative  Clipper.PolyFillTypePositive  Clipper.PolyFillTypeEvenOdd  Clipper.PolyFillTypeNonZero   source", 
            "title": "Clipping"
        }, 
        {
            "location": "/polygons/#offsetting", 
            "text": "#  Devices.Polygons.offset     Function .  offset { S :Coordinate } ( s :: AbstractPolygon { S } ,   delta :: Coordinate ; \n     j :: Clipper . JoinType = Clipper . JoinTypeMiter , \n     e :: Clipper . EndType = Clipper . EndTypeClosedPolygon )  offset { S :AbstractPolygon } ( subject :: AbstractVector { S } ,   delta :: Coordinate ; \n     j :: Clipper . JoinType = Clipper . JoinTypeMiter , \n     e :: Clipper . EndType = Clipper . EndTypeClosedPolygon )  offset { S :Polygon } ( s :: AbstractVector { S } ,   delta :: Coordinate ; \n     j :: Clipper . JoinType = Clipper . JoinTypeMiter , \n     e :: Clipper . EndType = Clipper . EndTypeClosedPolygon )   Using the  Clipper  library and the  Clipper.jl  wrapper, perform polygon offsetting.  The first argument should be an  AbstractPolygon . The second argument is how much to offset the polygon. Keyword arguments include a  join type :   Clipper.JoinTypeMiter  Clipper.JoinTypeRound  Clipper.JoinTypeSquare   and also an  end type :   Clipper.EndTypeClosedPolygon  Clipper.EndTypeClosedLine  Clipper.EndTypeOpenSquare  Clipper.EndTypeOpenRound  Clipper.EndTypeOpenButt   source", 
            "title": "Offsetting"
        }, 
        {
            "location": "/polygons/#rectangle-api", 
            "text": "#  Devices.Rectangles.Rectangle     Type .  struct Rectangle{T}  : AbstractPolygon{T}\n    ll::Point{T}\n    ur::Point{T}\n    function Rectangle(a,b)\n        # Ensure ll is lower-left, ur is upper-right.\n        ll = Point(a. =b) .* a + Point(b. =a) .* b\n        ur = Point(a. =b) .* b + Point(b. =a) .* a\n        new(ll,ur)\n    end\nend  A rectangle, defined by opposing lower-left and upper-right corner coordinates. Lower-left and upper-right are guaranteed to be such by the inner constructor.  source  #  Devices.Rectangles.Rectangle     Method .  Rectangle(ll::Point, ur::Point)  Convenience constructor for  Rectangle  objects.  source  #  Devices.Rectangles.Rectangle     Method .  Rectangle(width, height)  Constructs  Rectangle  objects by specifying the width and height rather than the lower-left and upper-right corners.  The rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of  Rectangle{Int}  type, this would not be possible if either  width  or  height  were odd numbers. This definition ensures type stability in the constructor.  source  #  Devices.bounds     Method .  bounds(r::Rectangle)  No-op (just returns  r ).  source  #  Devices.center     Method .  center(r::Rectangle)  Returns a  Point  corresponding to the center of the rectangle.  source  #  Devices.centered     Method .  centered(r::Rectangle)  Centers a copy of  r , with promoted coordinates if necessary. This function will not throw an  InexactError() , even if  r  had integer coordinates.  source  #  Devices.Rectangles.height     Method .  height(r::Rectangle)  Return the height of a rectangle.  source  #  Devices.Rectangles.isproper     Method .  isproper(r::Rectangle)  Returns  true  if the rectangle has a non-zero size. Otherwise, returns  false . Note that the upper-right and lower-left corners are enforced to be the  ur  and  ll  fields of a  Rectangle  by the inner constructor.  source  #  Devices.lowerleft     Method .  lowerleft(r::Rectangle)  Returns the lower-left corner of a rectangle (Point object).  source  #  Devices.upperright     Method .  upperright(r::Rectangle)  Returns the upper-right corner of a rectangle (Point object).  source  #  Devices.Polygons.points     Method .  points{T}(x::Rectangle{T})  Returns the array of  Point  objects defining the rectangle.  source  #  Devices.Rectangles.width     Method .  width(r::Rectangle)  Return the width of a rectangle.  source  #  Base.:+     Method .  +(r::Rectangle, p::Point)  Translate a rectangle by  p .  source", 
            "title": "Rectangle API"
        }, 
        {
            "location": "/polygons/#polygon-api", 
            "text": "#  Devices.Polygons.Polygon     Type .  struct Polygon{T}  : AbstractPolygon{T}\n    p::Vector{Point{T}}\n    Polygon(x) = new(x)\n    Polygon(x::AbstractPolygon) = convert(Polygon{T}, x)\nend  Polygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).  source  #  Devices.Polygons.Polygon     Method .  Polygon{T}(parr::AbstractVector{Point{T}})  Convenience constructor for a  Polygon{T}  object.  source  #  Devices.Polygons.Polygon     Method .  Polygon(p0::Point, p1::Point, p2::Point, p3::Point...)  Convenience constructor for a  Polygon{T}  object.  source  #  Devices.bounds     Method .  bounds(p::Polygon)  Return a bounding Rectangle for polygon  p .  source  #  Devices.bounds     Method .  bounds{T :AbstractPolygon}(parr::AbstractArray{T})  Return a bounding  Rectangle  for an array  parr  of  AbstractPolygon  objects.  source  #  Devices.bounds     Method .  bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  for several  AbstractPolygon  objects.  source  #  Devices.lowerleft     Method .  lowerleft(x::Polygon)  Return the lower-left-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  source  #  Devices.upperright     Method .  upperright(x::Polygon)  Return the upper-right-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  source  #  Devices.Polygons.points     Method .  points(x::Polygon)  Returns the array of  Point  objects defining the polygon.  source", 
            "title": "Polygon API"
        }, 
        {
            "location": "/cells/", 
            "text": "Cells are used to logically group polygons or references to other cells into a single entity. They can contain references to other cells or arrays of other cells. They also store polygons. Here is the definition of a \nCell\n:\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nType\n.\n\n\nmutable struct Cell{S\n:Coordinate, T\n:Meta}\n    name::String\n    elements::Vector{CellPolygon{S,T}}\n    refs::Vector{CellRef}\n    create::DateTime\n    Cell(x,y,z,t) = new(x, y, z, t)\n    Cell(x,y,z) = new(x, y, z, now())\n    Cell(x,y) = new(x, y, CellRef[], now())\n    Cell(x) = new(x, Polygon{T}[], CellRef[], now())\n    Cell() = begin\n        c = new()\n        c.elements = Polygon{T}[]\n        c.refs = CellRef[]\n        c.create = now()\n        c\n    end\nend\n\n\n\n\n\nA cell has a name and contains polygons and references to \nCellArray\n or \nCellReference\n objects. It also records the time of its own creation. As currently implemented it mirrors the notion of cells in GDS-II files.\n\n\nTo add elements, use \nrender!\n. To add references, push them to \nrefs\n field.\n\n\nsource\n\n\nThe type parameter \nS\n of a \nCell{S,T}\n object is used in two ways:\n\n\n\n\nDetermine the units of the coordinates of all polygons in a cell, as well as origins and offset vectors of \nCellArray\ns and \nCellReference\ns.\n\n\nDetermine whether the cell will contain integer coordinates or floating-point coordinates. Currently, you cannot do a whole lot (particularly with regard to paths) if the cell has integer coordinates. However, they do have an inherent advantage because the coordinates are exact, and ultimately the GDS-II file represents shapes with integer coordinates. In the future, we intend to improve support for cells with integer coordinates.\n\n\n\n\nFor instance, \nCell{typeof(1.0u\"nm\")}\n matches a cell where the database unit is \nnm\n and polygons may have \nFloat64\n-based coordinates (the type of \n1.0\n is \nFloat64\n). Note that \nCell{typeof(2.0u\"nm\")}\n does not mean the database unit is 2.0nm, because the returned type is the same. If that is intended, instead make a new unit such that one of that new unit is equal to 2nm. You can do this using the \n@unit\n macro in Unitful.\n\n\nFor most cases, if you want to use units, \nCell(\"my_cell_name\", nm)\n is a good way to construct a cell which will ultimately have all coordinates rounded to the nearest \nnm\n when exported into GDS-II. You can add polygons with whatever length units you want to such a cell, and the coordinates will be converted automatically to \nnm\n. You can change \nnm\n to \npm\n or \nfm\n or whatever, but this will limit the pattern extent and probably doesn't make sense anyway.\n\n\nIf you don't want units, just construct the cell with a name only: \nCell(\"my_cell_name\")\n will return a \nCell{Float64}\n object. In this case too, the ultimate database resolution is \n1nm\n; until exporting the cell into a GDS-II file, the coordinates are interpreted to be in units of \n1\u03bcm\n. This behavior cannot be changed for cells without units.\n\n\n\n\nCell API\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nMethod\n.\n\n\nCell(name::AbstractString)\n\n\n\n\n\nConvenience constructor for \nCell{Float64}\n.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds{T\n:Coordinate}(cell::Cell{T})\nbounds(cell0::Cell, cell1::Cell, cell::Cell...)\n\n\n\n\n\nReturns a \nRectangle\n bounding box around all objects in a cell or cells.\n\n\nsource\n\n\n#\n\n\nDevices.center\n \n \nMethod\n.\n\n\ncenter(cell::Cell)\n\n\n\n\n\nConvenience method, equivalent to \ncenter(bounds(cell))\n. Returns the center of the bounding box of the cell.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.name\n \n \nMethod\n.\n\n\nname(x::Cell)\n\n\n\n\n\nReturns the name of the cell.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.dbscale\n \n \nMethod\n.\n\n\ndbscale(c::Cell{T}) where {T}\n\n\n\n\n\nGive the database scale for a cell. The database scale is the smallest increment of length that will be represented in the output CAD file.\n\n\nFor \nCell{T\n:Length}\n, the database scale is \nT(1)\n. For floating-point lengths, this means that anything after the decimal point will be rounded off. For this reason, Cell{typeof(1.0nm)} is probably the most convenient type to work with.\n\n\nThe database scale of a \nCell{T\n:Real}\n is assumed to be \n1nm\n (\n1.0nm\n if \nT \n: AbstractFloat\n) because insufficient information is provided to know otherwise.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.dbscale\n \n \nMethod\n.\n\n\ndbscale(cell::Cell...)\n\n\n\n\n\nChoose an appropriate database scale for a GDSII file given \nCell\ns of different types. The smallest database scale of all cells considered is returned.\n\n\nsource\n\n\n\n\nReferenced and arrayed cells\n\n\nCells can be arrayed or referenced within other cells for efficiency or to reduce display complexity.\n\n\n    CellArray\n    CellArray{T\n:Devices.Coordinate}(::Any, ::Point{T})\n    CellArray{T\n:Devices.Coordinate}(::Any, ::Range{T}, ::Range{T})\n    CellReference\n    CellReference{T\n:Devices.Coordinate}(::Any, ::Point{T}=Point(0.,0.))\n    bounds{S\n:Devices.Coordinate, T\n:Devices.Coordinate}(::CellArray{T, Cell{S}})\n    bounds(::CellReference)\n    copy(::CellReference)\n    copy(::CellArray)\n    name(::CellReference)\n    name(::CellArray)\n    uniquename\n\n\n\n\n\n\n\nResolving references\n\n\nSometimes it can be helpful to go between coordinate systems of cells and the cells they reference. This package provides methods to generate affine transforms to do this as easily as possible.\n\n\n#\n\n\nCoordinateTransformations.transform\n \n \nMethod\n.\n\n\ntransform(c::Cell, d::CellRef)\n\n\n\n\n\nGiven a Cell \nc\n containing \nCellReference\n or \nCellArray\n \nd\n in its tree of references, this function returns a \nCoordinateTransformations.AffineMap\n object that lets you translate from the coordinate system of \nd\n to the coordinate system of \nc\n.\n\n\nIf the \nsame exact\n \nCellReference\n or \nCellArray\n (as in \n===\n, same address in memory) is included multiple times in the tree of references, then the resulting transform will be based on the first time it is encountered. The tree is traversed one level at a time to find the reference (optimized for shallow references).\n\n\nExample: You want to translate (2.0,3.0) in the coordinate system of the referenced cell \nd\n to the coordinate system of \nc\n:\n\n\njulia\n trans = transform(c,d)\n\njulia\n trans(Point(2.0,3.0))\n\n\n\n\n\nsource\n\n\nIn some cases it may be desirable to resolve cell references or arrays into their corresponding polygons. This operation is called \"flattening.\"\n\n\n#\n\n\nDevices.Cells.flatten!\n \n \nFunction\n.\n\n\nflatten!(c::Cell)\n\n\n\n\n\nAll cell references and arrays are turned into polygons and added to cell \nc\n. The references and arrays are then removed. This \"flattening\" of the cell is recursive: references in referenced cells are flattened too. The modified cell is returned.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.flatten\n \n \nFunction\n.\n\n\nflatten(c::Cell, name=uniquename(\nflatten\n))\n\n\n\n\n\nAll cell references and arrays are resolved into polygons, recursively. A new \nCell\n is returned containing these polygons, together with the polygons already explicitly in cell \nc\n. The cell \nc\n remains unmodified.\n\n\nsource\n\n\nflatten(c::CellReference, name=uniquename(\nflatten\n))\n\n\n\n\n\nCell reference \nc\n is resolved into polygons, recursively. A new \nCell\n is returned containing these polygons. The cell reference \nc\n remains unmodified.\n\n\nsource\n\n\nflatten(c::CellArray, name=uniquename(\nflatten\n))\n\n\n\n\n\nCell array \nc\n is resolved into polygons, recursively. A new \nCell\n is returned containing these polygons. The cell array \nc\n remains unmodified.\n\n\nsource\n\n\n\n\nMiscellaneous\n\n\nWhen saving cells to disk, keep in mind that cells should have unique names. We don't have an automatic renaming scheme implemented to avoid clashes. To help with this, we provide a function \nuniquename\n to generate unique names based on human-readable prefixes.\n\n\nWhen saving cells to disk, there will be a tree of interdependencies and logically one would prefer to write the leaf nodes of the tree before any dependent cells. These functions are used to traverse the tree and then find the optimal ordering.\n\n\n#\n\n\nDevices.Cells.traverse!\n \n \nFunction\n.\n\n\ntraverse!(a::AbstractArray, c::Cell, level=1)\n\n\n\n\n\nGiven a cell, recursively traverse its references for other cells and add to array \na\n some tuples: \n(level, c)\n. \nlevel\n corresponds to how deep the cell was found, and \nc\n is the found cell.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.order!\n \n \nFunction\n.\n\n\norder!(a::AbstractArray)\n\n\n\n\n\nGiven an array of tuples like that coming out of \ntraverse!\n, we sort by the \nlevel\n, strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).\n\n\nFor performance reasons, this function modifies \na\n but what you want is the returned result array.\n\n\nsource", 
            "title": "Cells"
        }, 
        {
            "location": "/cells/#cell-api", 
            "text": "#  Devices.Cells.Cell     Method .  Cell(name::AbstractString)  Convenience constructor for  Cell{Float64} .  source  #  Devices.bounds     Method .  bounds{T :Coordinate}(cell::Cell{T})\nbounds(cell0::Cell, cell1::Cell, cell::Cell...)  Returns a  Rectangle  bounding box around all objects in a cell or cells.  source  #  Devices.center     Method .  center(cell::Cell)  Convenience method, equivalent to  center(bounds(cell)) . Returns the center of the bounding box of the cell.  source  #  Devices.Cells.name     Method .  name(x::Cell)  Returns the name of the cell.  source  #  Devices.Cells.dbscale     Method .  dbscale(c::Cell{T}) where {T}  Give the database scale for a cell. The database scale is the smallest increment of length that will be represented in the output CAD file.  For  Cell{T :Length} , the database scale is  T(1) . For floating-point lengths, this means that anything after the decimal point will be rounded off. For this reason, Cell{typeof(1.0nm)} is probably the most convenient type to work with.  The database scale of a  Cell{T :Real}  is assumed to be  1nm  ( 1.0nm  if  T  : AbstractFloat ) because insufficient information is provided to know otherwise.  source  #  Devices.Cells.dbscale     Method .  dbscale(cell::Cell...)  Choose an appropriate database scale for a GDSII file given  Cell s of different types. The smallest database scale of all cells considered is returned.  source", 
            "title": "Cell API"
        }, 
        {
            "location": "/cells/#referenced-and-arrayed-cells", 
            "text": "Cells can be arrayed or referenced within other cells for efficiency or to reduce display complexity.      CellArray\n    CellArray{T :Devices.Coordinate}(::Any, ::Point{T})\n    CellArray{T :Devices.Coordinate}(::Any, ::Range{T}, ::Range{T})\n    CellReference\n    CellReference{T :Devices.Coordinate}(::Any, ::Point{T}=Point(0.,0.))\n    bounds{S :Devices.Coordinate, T :Devices.Coordinate}(::CellArray{T, Cell{S}})\n    bounds(::CellReference)\n    copy(::CellReference)\n    copy(::CellArray)\n    name(::CellReference)\n    name(::CellArray)\n    uniquename", 
            "title": "Referenced and arrayed cells"
        }, 
        {
            "location": "/cells/#resolving-references", 
            "text": "Sometimes it can be helpful to go between coordinate systems of cells and the cells they reference. This package provides methods to generate affine transforms to do this as easily as possible.  #  CoordinateTransformations.transform     Method .  transform(c::Cell, d::CellRef)  Given a Cell  c  containing  CellReference  or  CellArray   d  in its tree of references, this function returns a  CoordinateTransformations.AffineMap  object that lets you translate from the coordinate system of  d  to the coordinate system of  c .  If the  same exact   CellReference  or  CellArray  (as in  === , same address in memory) is included multiple times in the tree of references, then the resulting transform will be based on the first time it is encountered. The tree is traversed one level at a time to find the reference (optimized for shallow references).  Example: You want to translate (2.0,3.0) in the coordinate system of the referenced cell  d  to the coordinate system of  c :  julia  trans = transform(c,d)\n\njulia  trans(Point(2.0,3.0))  source  In some cases it may be desirable to resolve cell references or arrays into their corresponding polygons. This operation is called \"flattening.\"  #  Devices.Cells.flatten!     Function .  flatten!(c::Cell)  All cell references and arrays are turned into polygons and added to cell  c . The references and arrays are then removed. This \"flattening\" of the cell is recursive: references in referenced cells are flattened too. The modified cell is returned.  source  #  Devices.Cells.flatten     Function .  flatten(c::Cell, name=uniquename( flatten ))  All cell references and arrays are resolved into polygons, recursively. A new  Cell  is returned containing these polygons, together with the polygons already explicitly in cell  c . The cell  c  remains unmodified.  source  flatten(c::CellReference, name=uniquename( flatten ))  Cell reference  c  is resolved into polygons, recursively. A new  Cell  is returned containing these polygons. The cell reference  c  remains unmodified.  source  flatten(c::CellArray, name=uniquename( flatten ))  Cell array  c  is resolved into polygons, recursively. A new  Cell  is returned containing these polygons. The cell array  c  remains unmodified.  source", 
            "title": "Resolving references"
        }, 
        {
            "location": "/cells/#miscellaneous", 
            "text": "When saving cells to disk, keep in mind that cells should have unique names. We don't have an automatic renaming scheme implemented to avoid clashes. To help with this, we provide a function  uniquename  to generate unique names based on human-readable prefixes.  When saving cells to disk, there will be a tree of interdependencies and logically one would prefer to write the leaf nodes of the tree before any dependent cells. These functions are used to traverse the tree and then find the optimal ordering.  #  Devices.Cells.traverse!     Function .  traverse!(a::AbstractArray, c::Cell, level=1)  Given a cell, recursively traverse its references for other cells and add to array  a  some tuples:  (level, c) .  level  corresponds to how deep the cell was found, and  c  is the found cell.  source  #  Devices.Cells.order!     Function .  order!(a::AbstractArray)  Given an array of tuples like that coming out of  traverse! , we sort by the  level , strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).  For performance reasons, this function modifies  a  but what you want is the returned result array.  source", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/paths/", 
            "text": "A \nPaths.Path\n is an ordered collection of \nPaths.Node\ns, each of which has a \nPaths.Segment\n and a \nPaths.Style\n. The nodes are linked to each other, so each node knows what the previous and next nodes are.\n\n\n\n\nSegments\n\n\nEach subtype of \nSegment\n can represent a class of parametric functions \nt-\nPoint(x(t),y(t))\n. By \"class\" we mean e.g. \nPaths.Straight\n or \nPaths.Turn\n, which are used frequently. Instances of these subtypes of \nSegment\n have some captured variables to specify a particular path in the plane. Instances of \nTurn\n, for example, will capture an initial and final angle, a radius, and an origin. All circular turns may be parameterized with these variables.\n\n\n\n\nNote\n\n\nThis package assumes that the parametric functions are implemented such that $\\sqrt{((dx/dt)^2 + (dy/dt)^2)} = 1$. In other words, \nt\n ranges from zero to the path length of the segment.\n\n\n\n\n\n\nStyles\n\n\nEach subtype of \nStyle\n describes how to render a segment. You can create the most common styles using the constructors \nPaths.Trace\n (a trace with some width) and \nPaths.CPW\n (a coplanar waveguide style).\n\n\nOne can implement new styles by writing methods for \nrender!\n that dispatch on different style types. In this way, the rendering code can be specialized for the task at hand, improving performance and shrinking generated file sizes (ideally).\n\n\n\n\nCorners\n\n\nSharp turns in a path can be accomplished with \nPaths.corner!\n. Sharp turns pose a challenge to the path abstraction in that they have zero length, and when rendered effectively take up some length of the neighboring segments. These details are automatically accounted for by tweaking segment lengths and other captured segment variables just before rendering a path.\n\n\n\n\nAttachments\n\n\nattach!\n is one of the most useful functions defined in this package.\n\n\nWhen you call \nattach!\n, you are defining a coordinate system local to somewhere along the target \nPath\n, saying that a \nCellReference\n should be placed at the origin of that coordinate system (or slightly away from it if you want the cell to be one one side of the path or the other). The local coordinate system will rotate as the path changes orientations. The origin of the \nCellReference\n corresponds how the referenced cell should be displaced with respect to the origin of the local coordinate system. This differs from the usual meaning of the origin of a \nCellReference\n, which is how the referenced cell should be displaced with respect to the origin of a containing \nCell\n.\n\n\nThe same \nCellReference\n can be attached to multiple points along multiple paths. If the cell reference is modified (e.g. rotation, origin, magnification) before rendering, the changes should be reflected at all attachment points. The attachment of the cell reference is not a perfect abstraction: a \nCellReference\n must ultimately live inside a \nCell\n, but an unrendered \nPath\n does not live inside any cell. If the path is modified further before rendering, the attachment points will follow the path modifications, moving the origins of the local coordinate systems. The origin fields of the cell references do not change as the path is modified.\n\n\nAttachments are implemented by introducing a \nPaths.DecoratedStyle\n, which is kind of a meta-\nStyle\n: it remembers where to attach \nCellReferences\n, but how the path itself is actually drawn is deferred to a different \nStyle\n object that it retains a reference to. One can repeat a \nDecoratedStyle\n with one attachment to achieve a periodic placement of \nCellReferences\n (like a \nCellArray\n, but along the path). Or, one long segment with a \nDecoratedStyle\n could have several attachments to achieve a similar effect.\n\n\nWhen a \nPath\n is rendered, it is turned into \nPolygons\n living in some \nCell\n. The attachments remain \nCellReferences\n, now living inside of a \nCell\n and not tied to an abstract path. The notion of local coordinate systems along the path no longer makes sense because the abstract path has been made concrete, and the polygons are living in the coordinate system of the containing cell. Each attachment to the former path now must have its origin referenced to the origin of the containing cell, not to local path coordinate systems. Additionally, the references may need to rotate according to how the path was locally oriented. As a result, even if the same \nCellReference\n was attached multiple times to a path, now we need distinct \nCellReference\n objects for each attachment, as well as for each time a corresponding \nDecoratedStyle\n is rendered.\n\n\nSuppose we want the ability to transform between coordinate systems, especially between the coordinate system of a referenced cell and the coordinate system of a parent cell. At first glance it would seem like we could simply define a transform function, taking the parent cell and the cell reference we are interested in. But how would we actually identify the particular cell reference we want? Looking in the tree of references for an attached \nCellReference\n will not work: distinct \nCellReferences\n needed to be made after the path was rendered, and so the particular \nCellReference\n object initially attached is not actually in the \nCell\n containing the rendered path.\n\n\nTo overcome this problem, we make searching for the appropriate \nCellReference\n easier. Suppose a path with attachments has been rendered to a \nCell\n, which is bound to symbol \naaa\n. A \nCellReference\n referring to a cell named \"bbb\" was attached twice. To recall the second attachment: \naaa[\"bbb\",2]\n (the index defaults to 1 if unspecified). We can go deeper if we want to refer to references inside that attachment: \naaa[\"bbb\",2][\"ccc\"]\n. In this manner, it is easy to find the right \nCellReference\n to use with \nCells.transform(::Cell, ::Cells.CellRef)\n.\n\n\n\n\nPath API\n\n\n\n\nPath construction\n\n\n    Paths.Path\n    Paths.Path{T\n:Real}(::Point{T})\n\n\n\n\n\n\n\nPath interrogation\n\n\n#\n\n\nDevices.Paths.direction\n \n \nFunction\n.\n\n\ndirection(s, t)\n\n\n\n\n\nReturns the angle at which some function \nt-\nPoint(x(t),y(t))\n is pointing.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.pathlength\n \n \nFunction\n.\n\n\npathlength(p::Path)\npathlength{T}(array::AbstractArray{Node{T}})\npathlength{T\n:Segment}(array::AbstractArray{T})\npathlength(node::Node)\n\n\n\n\n\nPhysical length of a path. Note that \nlength\n will return the number of segments in a path, not the physical length of the path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.p0\n \n \nFunction\n.\n\n\np0{T}(s::Segment{T})\n\n\n\n\n\nReturn the first point in a segment (calculated).\n\n\nsource\n\n\np0(p::Path)\n\n\n\n\n\nFirst point of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.\u03b10\n \n \nFunction\n.\n\n\n\u03b10(s::Segment)\n\n\n\n\n\nReturn the first angle in a segment (calculated).\n\n\nsource\n\n\n\u03b10(p::Path)\n\n\n\n\n\nFirst angle of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.p1\n \n \nFunction\n.\n\n\np1{T}(s::Segment{T})\n\n\n\n\n\nReturn the last point in a segment (calculated).\n\n\nsource\n\n\np1(p::Path)\n\n\n\n\n\nLast point of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.\u03b11\n \n \nFunction\n.\n\n\n\u03b11(s::Segment)\n\n\n\n\n\nReturn the last angle in a segment (calculated).\n\n\nsource\n\n\n\u03b11(p::Path)\n\n\n\n\n\nLast angle of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.style0\n \n \nFunction\n.\n\n\nstyle0(p::Path)\n\n\n\n\n\nStyle of the first segment of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.style1\n \n \nFunction\n.\n\n\nstyle1(p::Path)\n\n\n\n\n\nStyle of the last segment of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.discretestyle1\n \n \nFunction\n.\n\n\ndiscretestyle1{T}(p::Path{T})\n\n\n\n\n\nReturns the last-used discrete style in the path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.contstyle1\n \n \nFunction\n.\n\n\ncontstyle1(p::Path)\n\n\n\n\n\nReturns the last-used discrete style in the path.\n\n\nsource\n\n\n\n\nPath manipulation\n\n\n#\n\n\nDevices.Paths.setp0!\n \n \nFunction\n.\n\n\nsetp0!(s::Straight, p::Point)\n\n\n\n\n\nSet the p0 of a straight segment.\n\n\nsource\n\n\nsetp0!(s::Turn, p::Point)\n\n\n\n\n\nSet the p0 of a turn.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.set\u03b10!\n \n \nFunction\n.\n\n\nset\u03b10!(s::Straight, \u03b10\u2032)\n\n\n\n\n\nSet the angle of a straight segment.\n\n\nsource\n\n\nset\u03b10!(s::Turn, \u03b10\u2032)\n\n\n\n\n\nSet the starting angle of a turn.\n\n\nsource\n\n\n#\n\n\nBase.append!\n \n \nMethod\n.\n\n\nappend!(p::Path, p\u2032::Path)\n\n\n\n\n\nGiven paths \np\n and \np\u2032\n, path \np\u2032\n is appended to path \np\n. The p0 and initial angle of the first segment from path \np\u2032\n is modified to match the last point and last angle of path \np\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.adjust!\n \n \nFunction\n.\n\n\nadjust!(p::Path, n::Integer=1)\n\n\n\n\n\nAdjust a path's parametric functions starting from index \nn\n. Used internally whenever segments are inserted into the path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.attach!\n \n \nFunction\n.\n\n\nattach\n!(\np\n::\nPath\n,\n \nc\n::\nCellReference\n,\n \nt\n::\nCoordinate\n;\n\n    \ni\n::\nInteger\n=\nlength\n(\np\n),\n \nlocation\n::\nInteger\n=\n0\n)\n\n\nattach\n!(\np\n::\nPath\n,\n \nc\n::\nCellReference\n,\n \nt\n;\n\n    \ni\n::\nInteger\n=\nlength\n(\np\n),\n \nlocation\n=\nzeros\n(\nInt\n,\n \nlength\n(\nt\n)))\n\n\n\n\n\n\nAttach \nc\n along a path. The second method permits ranges or arrays of \nt\n and \nlocation\n to be specified (if the lengths do not match, \nlocation\n is cycled).\n\n\nBy default, the attachment(s) occur at \nt \u2208 [zero(pathlength(s)),pathlength(s)]\n along the most recent path segment \ns\n, but a different path segment index can be specified using \ni\n. The reference is oriented with zero rotation if the path is pointing at 0\u00b0, otherwise it is rotated with the path.\n\n\nThe origin of the cell reference tells the method where to place the cell \nwith respect to a coordinate system that rotates with the path\n. Suppose the path is a straight line with angle 0\u00b0. Then an origin of \nPoint(0.,10.)\n will put the cell at 10 above the path, or 10 to the left of the path if it turns left by 90\u00b0.\n\n\nThe \nlocation\n option is for convenience. If \nlocation == 0\n, nothing special happens. If \nlocation == -1\n, then the point of attachment for the reference is on the leftmost edge of the waveguide (the rendered polygons; the path itself has no width). Likewise if \nlocation == 1\n, the point of attachment is on the rightmost edge. This option does not automatically rotate the cell reference, apart from what is already done as described in the first paragraph. You can think of this option as setting a special origin for the coordinate system that rotates with the path. For instance, an origin for the cell reference of \nPoint(0.,10.)\n together with \nlocation == -1\n will put the cell at 10 above the edge of a rendered (finite width) path with angle 0\u00b0.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.corner!\n \n \nFunction\n.\n\n\ncorner!{T\n:Coordinate}(p::Path{T}, \u03b1, sty::DiscreteStyle=discretestyle1(p))\n\n\n\n\n\nAppend a sharp turn or \"corner\" to path \np\n with angle \n\u03b1\n.\n\n\nThe style chosen for this corner, if not specified, is the last \nDiscreteStyle\n used in the path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.meander!\n \n \nFunction\n.\n\n\nmeander!(p::Path, len, straightlen, r, \u03b1)\n\n\n\n\n\nAlternate between going straight with length \nstraightlen\n and turning with radius \nr\n and angle \n\u03b1\n. Each turn goes the opposite direction of the previous. The total length is \nlen\n. Useful for making resonators.\n\n\nThe straight and turn segments are combined into a \nCompoundSegment\n and appended to the path \np\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.simplify\n \n \nFunction\n.\n\n\nsimplify(p::Path, inds::UnitRange=1:length(p))\n\n\n\n\n\nAt \ninds\n, segments of a path are turned into a \nCompoundSegment\n and styles of a path are turned into a \nCompoundStyle\n. The method returns a tuple, \n(segment, style)\n.\n\n\n\n\nIndexing the path becomes more sane when you can combine several path\n\n\n\n\nsegments into one logical element. A launcher would have several indices in a path unless you could simplify it.\n\n\n\n\nYou don't need to think hard about boundaries between straights and turns\n\n\n\n\nwhen you want a continuous styling of a very long path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.simplify!\n \n \nFunction\n.\n\n\nsimplify!(p::Path, inds::UnitRange=1:length(p))\n\n\n\n\n\nIn-place version of \nsimplify\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.straight!\n \n \nFunction\n.\n\n\nstraight!{T\n:Coordinate}(p::Path{T}, l::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))\n\n\n\n\n\nExtend a path \np\n straight by length \nl\n in the current direction. By default, we take the last continuous style in the path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.turn!\n \n \nFunction\n.\n\n\nturn!{T\n:Coordinate}(p::Path{T}, \u03b1, r::Coordinate, sty::Style=contstyle1(p))\n\n\n\n\n\nTurn a path \np\n by angle \n\u03b1\n with a turning radius \nr\n in the current direction. Positive angle turns left. By default, we take the last continuous style in the path.\n\n\nsource\n\n\nturn!{T\n:Coordinate}(p::Path{T}, s::String, r::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))\n\n\n\n\n\nTurn a path \np\n with direction coded by string \ns\n:\n\n\n\n\n\"l\": turn by \u03c0/2 radians (left)\n\n\n\"r\": turn by -\u03c0/2 radians (right)\n\n\n\"lrlrllrrll\": do those turns in that order\n\n\n\n\nBy default, we take the last continuous style in the path.\n\n\nsource\n\n\n\n\nNode API\n\n\n\n\nNode construction\n\n\n#\n\n\nDevices.Paths.Node\n \n \nType\n.\n\n\nNode{T}(a::Segment{T}, b::Style)\n\n\n\n\n\nCreate a node with segment \na\n and style \nb\n.\n\n\nsource\n\n\n\n\nNode methods\n\n\n#\n\n\nDevices.Paths.previous\n \n \nFunction\n.\n\n\nprevious(x::Node)\n\n\n\n\n\nReturn the node before \nx\n in a doubly linked list.\n\n\nsource\n\n\n#\n\n\nBase.next\n \n \nFunction\n.\n\n\nnext(iter, state) -\n item, state\n\n\n\n\n\nFor a given iterable object and iteration state, return the current item and the next iteration state.\n\n\njulia\n next(1:5, 3)\n(3, 4)\n\njulia\n next(1:5, 5)\n(5, 6)\n\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Paths.segment\n \n \nFunction\n.\n\n\nsegment(x::Node)\n\n\n\n\n\nReturn the segment associated with node \nx\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.style\n \n \nFunction\n.\n\n\nstyle(x::Node)\n\n\n\n\n\nReturn the style associated with node \nx\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.setsegment!\n \n \nFunction\n.\n\n\nsetsegment!(x::Node, s::Segment)\n\n\n\n\n\nSet the segment associated with node \nx\n to \ns\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.setstyle!\n \n \nFunction\n.\n\n\nsetstyle!(x::Node, s::Style)\n\n\n\n\n\nSet the style associated with node \nx\n to \ns\n.\n\n\nsource\n\n\n\n\nSegment API\n\n\n\n\nAbstract types\n\n\n#\n\n\nDevices.Paths.Segment\n \n \nType\n.\n\n\nabstract type Segment{T\n:Coordinate} end\n\n\n\n\n\nPath segment in the plane. All Segment objects should have the implement the following methods:\n\n\n\n\npathlength\n\n\np0\n\n\n\u03b10\n\n\nsetp0!\n\n\nset\u03b10!\n\n\n\u03b11\n\n\n\n\nsource\n\n\n\n\nConcrete types\n\n\n#\n\n\nDevices.Paths.Straight\n \n \nType\n.\n\n\nmutable struct Straight{T} \n: ContinuousSegment{T}\n    l::T\n    p0::Point{T}\n    \u03b10::typeof(0.0\u00b0)\nend\n\n\n\n\n\nA straight line segment is parameterized by its length. It begins at a point \np0\n with initial angle \n\u03b10\n.\n\n\nThe parametric function describing the line segment is given by \nt -\n p0 + Point(t*cos(\u03b1),t*sin(\u03b1))\n where \nt\n is a length from 0 to \nl\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.Turn\n \n \nType\n.\n\n\nmutable struct Turn{T} \n: ContinuousSegment{T}\n    \u03b1::typeof(1.0\u00b0)\n    r::T\n    p0::Point{T}\n    \u03b10::typeof(1.0\u00b0)\nend\n\n\n\n\n\nA circular turn is parameterized by the turn angle \n\u03b1\n and turning radius \nr\n. It begins at a point \np0\n with initial angle \n\u03b10\n.\n\n\nThe center of the circle is given by:\n\n\ncen = p0 + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the turn is given by:\n\n\nt -\n cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))\n\n\nsource\n\n\n#\n\n\nDevices.Paths.Corner\n \n \nType\n.\n\n\nmutable struct Corner{T} \n: DiscreteSegment{T}\n    \u03b1::Float64\n    p0::Point{T}\n    \u03b10::Float64\n    extent::T\n    Corner(a) = new(a, Point(zero(T), zero(T)), 0.0, zero(T))\n    Corner(a,b,c,d) = new(a,b,c,d)\nend\n\n\n\n\n\nA corner, or sudden kink in a path. The only parameter is the angle \n\u03b1\n of the kink. The kink begins at a point \np0\n with initial angle \n\u03b10\n. It will also end at \np0\n, since the corner has zero path length. However, during rendering, neighboring segments will be tweaked slightly so that the rendered path is properly centered about the path function (the rendered corner has a finite width).\n\n\nsource\n\n\n#\n\n\nDevices.Paths.CompoundSegment\n \n \nType\n.\n\n\nstruct CompoundSegment{T} \n: ContinuousSegment{T}\n    segments::Vector{Segment{T}}\n\n    CompoundSegment(segments) = begin\n        if any(x-\nisa(x,Corner), segments)\n            error(\ncannot have corners in a `CompoundSegment`. You may have \n,\n                \ntried to simplify a path containing `Corner` objects.\n)\n        else\n            new(deepcopy(Array(segments)))\n        end\n    end\nend\n\n\n\n\n\nConsider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes. The array of segments given to the constructor is copied and retained by the compound segment.\n\n\nNote that \nCorner\ns introduce a discontinuity in the derivative of the path function, and are not allowed in a \nCompoundSegment\n.\n\n\nsource\n\n\n\n\nStyle API\n\n\n\n\nConstructors and methods\n\n\n#\n\n\nDevices.Paths.Trace\n \n \nType\n.\n\n\nTrace(width)\nTrace(width::Coordinate)\n\n\n\n\n\nConstructor for Trace styles. Automatically chooses \nSimpleTrace\n or \nGeneralTrace\n as appropriate.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.CPW\n \n \nType\n.\n\n\nCPW(trace::Coordinate, gap::Coordinate)\nCPW(trace, gap::Coordinate)\nCPW(trace::Coordinate, gap)\nCPW(trace, gap)\n\n\n\n\n\nConstructors for CPW styles. Automatically chooses between \nSimpleCPW\n or \nGeneralCPW\n styles as appropriate.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.undecorated\n \n \nFunction\n.\n\n\nundecorated(s::DecoratedStyle)\nundecorated(s::Style)\n\n\n\n\n\nReturns the underlying, undecorated style if decorated; otherwise just return the style.\n\n\nsource\n\n\n\n\nAbstract types\n\n\n#\n\n\nDevices.Paths.Style\n \n \nType\n.\n\n\nabstract type Style end\n\n\n\n\n\nHow to render a given path segment. All styles should implement the following methods:\n\n\n\n\nextent\n\n\nwidth\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Paths.ContinuousStyle\n \n \nType\n.\n\n\nabstract type ContinuousStyle \n: Style end\n\n\n\n\n\nAny style that applies to segments which have non-zero path length.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.DiscreteStyle\n \n \nType\n.\n\n\nabstract type DiscreteStyle \n: Style end\n\n\n\n\n\nAny style that applies to segments which have zero path length.\n\n\nsource\n\n\n\n\nConcrete types\n\n\n#\n\n\nDevices.Paths.SimpleTrace\n \n \nType\n.\n\n\nstruct SimpleTrace{T\n:Coordinate} \n: Trace\n    width::T\nend\n\n\n\n\n\nA single trace with fixed width as a function of path length.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.GeneralTrace\n \n \nType\n.\n\n\nstruct GeneralTrace{T} \n: Trace\n    width::T\nend\n\n\n\n\n\nA single trace with variable width as a function of path length. \nwidth\n is callable.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.SimpleCPW\n \n \nType\n.\n\n\nstruct SimpleCPW{T\n:Coordinate} \n: CPW\n    trace::T\n    gap::T\nend\n\n\n\n\n\nA CPW with fixed trace and gap as a function of path length.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.GeneralCPW\n \n \nType\n.\n\n\nstruct GeneralCPW{S,T} \n: CPW\n    trace::S\n    gap::T\nend\n\n\n\n\n\nA CPW with variable trace and gap as a function of path length. \ntrace\n and \ngap\n are callable.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.CompoundStyle\n \n \nType\n.\n\n\nstruct CompoundStyle \n: ContinuousStyle\n    styles::Vector{Style}\n    grid::Vector{Float64}\nend\n\n\n\n\n\nCombines styles together, typically for use with a \nCompoundSegment\n.\n\n\n\n\nstyles\n: Array of styles making up the object. This is shallow-copied\n\n\n\n\nby the outer constructor.\n\n\n\n\ngrid\n: An array of \nt\n values needed for rendering the parameteric path.\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Paths.DecoratedStyle\n \n \nType\n.\n\n\nmutable struct DecoratedStyle{T\n:FloatCoordinate} \n: ContinuousStyle\n    s::Style\n    ts::Array{Float64,1}\n    dirs::Array{Int,1}\n    refs::Array{CellReference,1}\nend\n\n\n\n\n\nStyle with decorations, like structures periodically repeated along the path, etc.\n\n\nsource", 
            "title": "Paths"
        }, 
        {
            "location": "/paths/#segments", 
            "text": "Each subtype of  Segment  can represent a class of parametric functions  t- Point(x(t),y(t)) . By \"class\" we mean e.g.  Paths.Straight  or  Paths.Turn , which are used frequently. Instances of these subtypes of  Segment  have some captured variables to specify a particular path in the plane. Instances of  Turn , for example, will capture an initial and final angle, a radius, and an origin. All circular turns may be parameterized with these variables.   Note  This package assumes that the parametric functions are implemented such that $\\sqrt{((dx/dt)^2 + (dy/dt)^2)} = 1$. In other words,  t  ranges from zero to the path length of the segment.", 
            "title": "Segments"
        }, 
        {
            "location": "/paths/#styles", 
            "text": "Each subtype of  Style  describes how to render a segment. You can create the most common styles using the constructors  Paths.Trace  (a trace with some width) and  Paths.CPW  (a coplanar waveguide style).  One can implement new styles by writing methods for  render!  that dispatch on different style types. In this way, the rendering code can be specialized for the task at hand, improving performance and shrinking generated file sizes (ideally).", 
            "title": "Styles"
        }, 
        {
            "location": "/paths/#corners", 
            "text": "Sharp turns in a path can be accomplished with  Paths.corner! . Sharp turns pose a challenge to the path abstraction in that they have zero length, and when rendered effectively take up some length of the neighboring segments. These details are automatically accounted for by tweaking segment lengths and other captured segment variables just before rendering a path.", 
            "title": "Corners"
        }, 
        {
            "location": "/paths/#attachments", 
            "text": "attach!  is one of the most useful functions defined in this package.  When you call  attach! , you are defining a coordinate system local to somewhere along the target  Path , saying that a  CellReference  should be placed at the origin of that coordinate system (or slightly away from it if you want the cell to be one one side of the path or the other). The local coordinate system will rotate as the path changes orientations. The origin of the  CellReference  corresponds how the referenced cell should be displaced with respect to the origin of the local coordinate system. This differs from the usual meaning of the origin of a  CellReference , which is how the referenced cell should be displaced with respect to the origin of a containing  Cell .  The same  CellReference  can be attached to multiple points along multiple paths. If the cell reference is modified (e.g. rotation, origin, magnification) before rendering, the changes should be reflected at all attachment points. The attachment of the cell reference is not a perfect abstraction: a  CellReference  must ultimately live inside a  Cell , but an unrendered  Path  does not live inside any cell. If the path is modified further before rendering, the attachment points will follow the path modifications, moving the origins of the local coordinate systems. The origin fields of the cell references do not change as the path is modified.  Attachments are implemented by introducing a  Paths.DecoratedStyle , which is kind of a meta- Style : it remembers where to attach  CellReferences , but how the path itself is actually drawn is deferred to a different  Style  object that it retains a reference to. One can repeat a  DecoratedStyle  with one attachment to achieve a periodic placement of  CellReferences  (like a  CellArray , but along the path). Or, one long segment with a  DecoratedStyle  could have several attachments to achieve a similar effect.  When a  Path  is rendered, it is turned into  Polygons  living in some  Cell . The attachments remain  CellReferences , now living inside of a  Cell  and not tied to an abstract path. The notion of local coordinate systems along the path no longer makes sense because the abstract path has been made concrete, and the polygons are living in the coordinate system of the containing cell. Each attachment to the former path now must have its origin referenced to the origin of the containing cell, not to local path coordinate systems. Additionally, the references may need to rotate according to how the path was locally oriented. As a result, even if the same  CellReference  was attached multiple times to a path, now we need distinct  CellReference  objects for each attachment, as well as for each time a corresponding  DecoratedStyle  is rendered.  Suppose we want the ability to transform between coordinate systems, especially between the coordinate system of a referenced cell and the coordinate system of a parent cell. At first glance it would seem like we could simply define a transform function, taking the parent cell and the cell reference we are interested in. But how would we actually identify the particular cell reference we want? Looking in the tree of references for an attached  CellReference  will not work: distinct  CellReferences  needed to be made after the path was rendered, and so the particular  CellReference  object initially attached is not actually in the  Cell  containing the rendered path.  To overcome this problem, we make searching for the appropriate  CellReference  easier. Suppose a path with attachments has been rendered to a  Cell , which is bound to symbol  aaa . A  CellReference  referring to a cell named \"bbb\" was attached twice. To recall the second attachment:  aaa[\"bbb\",2]  (the index defaults to 1 if unspecified). We can go deeper if we want to refer to references inside that attachment:  aaa[\"bbb\",2][\"ccc\"] . In this manner, it is easy to find the right  CellReference  to use with  Cells.transform(::Cell, ::Cells.CellRef) .", 
            "title": "Attachments"
        }, 
        {
            "location": "/paths/#path-api", 
            "text": "", 
            "title": "Path API"
        }, 
        {
            "location": "/paths/#path-construction", 
            "text": "Paths.Path\n    Paths.Path{T :Real}(::Point{T})", 
            "title": "Path construction"
        }, 
        {
            "location": "/paths/#path-interrogation", 
            "text": "#  Devices.Paths.direction     Function .  direction(s, t)  Returns the angle at which some function  t- Point(x(t),y(t))  is pointing.  source  #  Devices.Paths.pathlength     Function .  pathlength(p::Path)\npathlength{T}(array::AbstractArray{Node{T}})\npathlength{T :Segment}(array::AbstractArray{T})\npathlength(node::Node)  Physical length of a path. Note that  length  will return the number of segments in a path, not the physical length of the path.  source  #  Devices.Paths.p0     Function .  p0{T}(s::Segment{T})  Return the first point in a segment (calculated).  source  p0(p::Path)  First point of a path.  source  #  Devices.Paths.\u03b10     Function .  \u03b10(s::Segment)  Return the first angle in a segment (calculated).  source  \u03b10(p::Path)  First angle of a path.  source  #  Devices.Paths.p1     Function .  p1{T}(s::Segment{T})  Return the last point in a segment (calculated).  source  p1(p::Path)  Last point of a path.  source  #  Devices.Paths.\u03b11     Function .  \u03b11(s::Segment)  Return the last angle in a segment (calculated).  source  \u03b11(p::Path)  Last angle of a path.  source  #  Devices.Paths.style0     Function .  style0(p::Path)  Style of the first segment of a path.  source  #  Devices.Paths.style1     Function .  style1(p::Path)  Style of the last segment of a path.  source  #  Devices.Paths.discretestyle1     Function .  discretestyle1{T}(p::Path{T})  Returns the last-used discrete style in the path.  source  #  Devices.Paths.contstyle1     Function .  contstyle1(p::Path)  Returns the last-used discrete style in the path.  source", 
            "title": "Path interrogation"
        }, 
        {
            "location": "/paths/#path-manipulation", 
            "text": "#  Devices.Paths.setp0!     Function .  setp0!(s::Straight, p::Point)  Set the p0 of a straight segment.  source  setp0!(s::Turn, p::Point)  Set the p0 of a turn.  source  #  Devices.Paths.set\u03b10!     Function .  set\u03b10!(s::Straight, \u03b10\u2032)  Set the angle of a straight segment.  source  set\u03b10!(s::Turn, \u03b10\u2032)  Set the starting angle of a turn.  source  #  Base.append!     Method .  append!(p::Path, p\u2032::Path)  Given paths  p  and  p\u2032 , path  p\u2032  is appended to path  p . The p0 and initial angle of the first segment from path  p\u2032  is modified to match the last point and last angle of path  p .  source  #  Devices.Paths.adjust!     Function .  adjust!(p::Path, n::Integer=1)  Adjust a path's parametric functions starting from index  n . Used internally whenever segments are inserted into the path.  source  #  Devices.Paths.attach!     Function .  attach !( p :: Path ,   c :: CellReference ,   t :: Coordinate ; \n     i :: Integer = length ( p ),   location :: Integer = 0 )  attach !( p :: Path ,   c :: CellReference ,   t ; \n     i :: Integer = length ( p ),   location = zeros ( Int ,   length ( t )))   Attach  c  along a path. The second method permits ranges or arrays of  t  and  location  to be specified (if the lengths do not match,  location  is cycled).  By default, the attachment(s) occur at  t \u2208 [zero(pathlength(s)),pathlength(s)]  along the most recent path segment  s , but a different path segment index can be specified using  i . The reference is oriented with zero rotation if the path is pointing at 0\u00b0, otherwise it is rotated with the path.  The origin of the cell reference tells the method where to place the cell  with respect to a coordinate system that rotates with the path . Suppose the path is a straight line with angle 0\u00b0. Then an origin of  Point(0.,10.)  will put the cell at 10 above the path, or 10 to the left of the path if it turns left by 90\u00b0.  The  location  option is for convenience. If  location == 0 , nothing special happens. If  location == -1 , then the point of attachment for the reference is on the leftmost edge of the waveguide (the rendered polygons; the path itself has no width). Likewise if  location == 1 , the point of attachment is on the rightmost edge. This option does not automatically rotate the cell reference, apart from what is already done as described in the first paragraph. You can think of this option as setting a special origin for the coordinate system that rotates with the path. For instance, an origin for the cell reference of  Point(0.,10.)  together with  location == -1  will put the cell at 10 above the edge of a rendered (finite width) path with angle 0\u00b0.  source  #  Devices.Paths.corner!     Function .  corner!{T :Coordinate}(p::Path{T}, \u03b1, sty::DiscreteStyle=discretestyle1(p))  Append a sharp turn or \"corner\" to path  p  with angle  \u03b1 .  The style chosen for this corner, if not specified, is the last  DiscreteStyle  used in the path.  source  #  Devices.Paths.meander!     Function .  meander!(p::Path, len, straightlen, r, \u03b1)  Alternate between going straight with length  straightlen  and turning with radius  r  and angle  \u03b1 . Each turn goes the opposite direction of the previous. The total length is  len . Useful for making resonators.  The straight and turn segments are combined into a  CompoundSegment  and appended to the path  p .  source  #  Devices.Paths.simplify     Function .  simplify(p::Path, inds::UnitRange=1:length(p))  At  inds , segments of a path are turned into a  CompoundSegment  and styles of a path are turned into a  CompoundStyle . The method returns a tuple,  (segment, style) .   Indexing the path becomes more sane when you can combine several path   segments into one logical element. A launcher would have several indices in a path unless you could simplify it.   You don't need to think hard about boundaries between straights and turns   when you want a continuous styling of a very long path.  source  #  Devices.Paths.simplify!     Function .  simplify!(p::Path, inds::UnitRange=1:length(p))  In-place version of  simplify .  source  #  Devices.Paths.straight!     Function .  straight!{T :Coordinate}(p::Path{T}, l::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))  Extend a path  p  straight by length  l  in the current direction. By default, we take the last continuous style in the path.  source  #  Devices.Paths.turn!     Function .  turn!{T :Coordinate}(p::Path{T}, \u03b1, r::Coordinate, sty::Style=contstyle1(p))  Turn a path  p  by angle  \u03b1  with a turning radius  r  in the current direction. Positive angle turns left. By default, we take the last continuous style in the path.  source  turn!{T :Coordinate}(p::Path{T}, s::String, r::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))  Turn a path  p  with direction coded by string  s :   \"l\": turn by \u03c0/2 radians (left)  \"r\": turn by -\u03c0/2 radians (right)  \"lrlrllrrll\": do those turns in that order   By default, we take the last continuous style in the path.  source", 
            "title": "Path manipulation"
        }, 
        {
            "location": "/paths/#node-api", 
            "text": "", 
            "title": "Node API"
        }, 
        {
            "location": "/paths/#node-construction", 
            "text": "#  Devices.Paths.Node     Type .  Node{T}(a::Segment{T}, b::Style)  Create a node with segment  a  and style  b .  source", 
            "title": "Node construction"
        }, 
        {
            "location": "/paths/#node-methods", 
            "text": "#  Devices.Paths.previous     Function .  previous(x::Node)  Return the node before  x  in a doubly linked list.  source  #  Base.next     Function .  next(iter, state) -  item, state  For a given iterable object and iteration state, return the current item and the next iteration state.  julia  next(1:5, 3)\n(3, 4)\n\njulia  next(1:5, 5)\n(5, 6)  source  #  Devices.Paths.segment     Function .  segment(x::Node)  Return the segment associated with node  x .  source  #  Devices.Paths.style     Function .  style(x::Node)  Return the style associated with node  x .  source  #  Devices.Paths.setsegment!     Function .  setsegment!(x::Node, s::Segment)  Set the segment associated with node  x  to  s .  source  #  Devices.Paths.setstyle!     Function .  setstyle!(x::Node, s::Style)  Set the style associated with node  x  to  s .  source", 
            "title": "Node methods"
        }, 
        {
            "location": "/paths/#segment-api", 
            "text": "", 
            "title": "Segment API"
        }, 
        {
            "location": "/paths/#abstract-types", 
            "text": "#  Devices.Paths.Segment     Type .  abstract type Segment{T :Coordinate} end  Path segment in the plane. All Segment objects should have the implement the following methods:   pathlength  p0  \u03b10  setp0!  set\u03b10!  \u03b11   source", 
            "title": "Abstract types"
        }, 
        {
            "location": "/paths/#concrete-types", 
            "text": "#  Devices.Paths.Straight     Type .  mutable struct Straight{T}  : ContinuousSegment{T}\n    l::T\n    p0::Point{T}\n    \u03b10::typeof(0.0\u00b0)\nend  A straight line segment is parameterized by its length. It begins at a point  p0  with initial angle  \u03b10 .  The parametric function describing the line segment is given by  t -  p0 + Point(t*cos(\u03b1),t*sin(\u03b1))  where  t  is a length from 0 to  l .  source  #  Devices.Paths.Turn     Type .  mutable struct Turn{T}  : ContinuousSegment{T}\n    \u03b1::typeof(1.0\u00b0)\n    r::T\n    p0::Point{T}\n    \u03b10::typeof(1.0\u00b0)\nend  A circular turn is parameterized by the turn angle  \u03b1  and turning radius  r . It begins at a point  p0  with initial angle  \u03b10 .  The center of the circle is given by:  cen = p0 + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))  The parametric function over  t \u2208 [0,1]  describing the turn is given by:  t -  cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))  source  #  Devices.Paths.Corner     Type .  mutable struct Corner{T}  : DiscreteSegment{T}\n    \u03b1::Float64\n    p0::Point{T}\n    \u03b10::Float64\n    extent::T\n    Corner(a) = new(a, Point(zero(T), zero(T)), 0.0, zero(T))\n    Corner(a,b,c,d) = new(a,b,c,d)\nend  A corner, or sudden kink in a path. The only parameter is the angle  \u03b1  of the kink. The kink begins at a point  p0  with initial angle  \u03b10 . It will also end at  p0 , since the corner has zero path length. However, during rendering, neighboring segments will be tweaked slightly so that the rendered path is properly centered about the path function (the rendered corner has a finite width).  source  #  Devices.Paths.CompoundSegment     Type .  struct CompoundSegment{T}  : ContinuousSegment{T}\n    segments::Vector{Segment{T}}\n\n    CompoundSegment(segments) = begin\n        if any(x- isa(x,Corner), segments)\n            error( cannot have corners in a `CompoundSegment`. You may have  ,\n                 tried to simplify a path containing `Corner` objects. )\n        else\n            new(deepcopy(Array(segments)))\n        end\n    end\nend  Consider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes. The array of segments given to the constructor is copied and retained by the compound segment.  Note that  Corner s introduce a discontinuity in the derivative of the path function, and are not allowed in a  CompoundSegment .  source", 
            "title": "Concrete types"
        }, 
        {
            "location": "/paths/#style-api", 
            "text": "", 
            "title": "Style API"
        }, 
        {
            "location": "/paths/#constructors-and-methods", 
            "text": "#  Devices.Paths.Trace     Type .  Trace(width)\nTrace(width::Coordinate)  Constructor for Trace styles. Automatically chooses  SimpleTrace  or  GeneralTrace  as appropriate.  source  #  Devices.Paths.CPW     Type .  CPW(trace::Coordinate, gap::Coordinate)\nCPW(trace, gap::Coordinate)\nCPW(trace::Coordinate, gap)\nCPW(trace, gap)  Constructors for CPW styles. Automatically chooses between  SimpleCPW  or  GeneralCPW  styles as appropriate.  source  #  Devices.Paths.undecorated     Function .  undecorated(s::DecoratedStyle)\nundecorated(s::Style)  Returns the underlying, undecorated style if decorated; otherwise just return the style.  source", 
            "title": "Constructors and methods"
        }, 
        {
            "location": "/paths/#abstract-types_1", 
            "text": "#  Devices.Paths.Style     Type .  abstract type Style end  How to render a given path segment. All styles should implement the following methods:   extent  width   source  #  Devices.Paths.ContinuousStyle     Type .  abstract type ContinuousStyle  : Style end  Any style that applies to segments which have non-zero path length.  source  #  Devices.Paths.DiscreteStyle     Type .  abstract type DiscreteStyle  : Style end  Any style that applies to segments which have zero path length.  source", 
            "title": "Abstract types"
        }, 
        {
            "location": "/paths/#concrete-types_1", 
            "text": "#  Devices.Paths.SimpleTrace     Type .  struct SimpleTrace{T :Coordinate}  : Trace\n    width::T\nend  A single trace with fixed width as a function of path length.  source  #  Devices.Paths.GeneralTrace     Type .  struct GeneralTrace{T}  : Trace\n    width::T\nend  A single trace with variable width as a function of path length.  width  is callable.  source  #  Devices.Paths.SimpleCPW     Type .  struct SimpleCPW{T :Coordinate}  : CPW\n    trace::T\n    gap::T\nend  A CPW with fixed trace and gap as a function of path length.  source  #  Devices.Paths.GeneralCPW     Type .  struct GeneralCPW{S,T}  : CPW\n    trace::S\n    gap::T\nend  A CPW with variable trace and gap as a function of path length.  trace  and  gap  are callable.  source  #  Devices.Paths.CompoundStyle     Type .  struct CompoundStyle  : ContinuousStyle\n    styles::Vector{Style}\n    grid::Vector{Float64}\nend  Combines styles together, typically for use with a  CompoundSegment .   styles : Array of styles making up the object. This is shallow-copied   by the outer constructor.   grid : An array of  t  values needed for rendering the parameteric path.   source  #  Devices.Paths.DecoratedStyle     Type .  mutable struct DecoratedStyle{T :FloatCoordinate}  : ContinuousStyle\n    s::Style\n    ts::Array{Float64,1}\n    dirs::Array{Int,1}\n    refs::Array{CellReference,1}\nend  Style with decorations, like structures periodically repeated along the path, etc.  source", 
            "title": "Concrete types"
        }, 
        {
            "location": "/shapes/", 
            "text": "Examples on this page assume you have done \nusing Devices, Devices.PreferMicrons, FileIO\n.\n\n\n#\n\n\nDevices.Microwave.bridge!\n \n \nFunction\n.\n\n\nbridge!(c::Cell, steps, foot_width, foot_height, span, metas::AbstractVector{\n:Meta})\n\n\n\n\n\nRenders polygons to cell \nc\n to construct a bridge. Can be called twice to construct a bridge with a hopover.\n\n\n\n\nsteps\n: Number of discrete steps in the bridge height.\n\n\nfoot_width\n: Width of the foot.\n\n\nfoot_height\n: Height of the bridge foot (in the plane).\n\n\nspan\n: Length of the bridge span.\n\n\nmetas\n: A vector of \nMeta\n objects with length \nsteps + 1\n. The first object is the \nMeta\n for the bridge foot and the others are for the bridge steps, in order.\n\n\n\n\n    \n-\nf.w.\n-\n                          \n-\nf.w.\n-\n\n    \n******************************************\n  \n---\n\n    \n|+++++|\n                            \n|+++++|\n   \n|\n\n    \n|+++++|\n                            \n|+++++|\n   \n|\n\n    \n|+++++|\n                            \n|+++++|\n   \n|\n\n    \n|+++++|\n-----------\nspan\n-----------\n|+++++|\n   \n|\n foot height\n    \n|+++++|\n                            \n|+++++|\n   \n|\n\n    \n|+++++|\n                            \n|+++++|\n   \n|\n\n    \n|+++++|\n                            \n|+++++|\n   \n|\n\n    \n******************************************\n  \n---\n\n\n\n\n\n\nThe profile of the bridge is given as \nh(x) = H*(2 - cosh(2*cosh^(-1)(2) x/L))\n where \nH\n is the height of bridge and \nL\n is the total span of bridge. The inverse of h(x) is taken to compute the size of each layer.\n\n\nsource\n\n\n#\n\n\nDevices.Microwave.device_template!\n \n \nFunction\n.\n\n\ndevice_template!{T}(d::Cell{T}, chip_meta::Meta, writeable_meta::Meta, marker_meta::Meta)\n\n\n\n\n\nIn cell \nc\n, make a template for a 1cm x 1cm chip. Includes chip outline, usable area outline, and markers.\n\n\nsource\n\n\n#\n\n\nDevices.Microwave.checkerboard!\n \n \nFunction\n.\n\n\ncheckerboard!{T}(c::Cell{T}, pixsize, rows::Integer, alt, meta::Meta=GDSMeta())\n\n\n\n\n\nIn cell \nc\n, generate a checkerboard pattern suitable for contrast curve measurement, or getting the base dose for PEC.\n\n\n\n\npixsize\n: length of one side of a square\n\n\nrows\n: number of rows == number of columns\n\n\nalt\n: the square nearest \nPoint(zero(T), zero(T))\n is filled (unfilled) if \nfalse\n (\ntrue\n). Use this to create a full tiling of the checkerboard, if you wish.\n\n\n\n\nsource\n\n\nExample:\n\n\nc\n \n=\n \nCell\n(\nmain\n,\n \nnm\n)\n\n\ncheckerboard!\n(\nc\n,\n \n20\n\u03bcm\n,\n \n10\n,\n \nfalse\n,\n \nGDSMeta\n(\n2\n))\n\n\ncheckerboard!\n(\nc\n,\n \n20\n\u03bcm\n,\n \n10\n,\n \ntrue\n,\n \nGDSMeta\n(\n3\n))\n\n\n\n\n\n\n\n\n#\n\n\nDevices.Microwave.grating!\n \n \nFunction\n.\n\n\ngrating!{T}(c::Cell{T}, line, space, size, meta::Meta=GDSMeta())\n\n\n\n\n\nGenerate a square grating suitable e.g. for obtaining the base dose for PEC.\n\n\nsource\n\n\nExample:\n\n\nc\n \n=\n \nCell\n(\nmain\n,\n \nnm\n)\n\n\ngrating!\n(\nc\n,\n \n100\nnm\n,\n \n100\nnm\n,\n \n5\n\u03bcm\n,\n \nGDSMeta\n(\n3\n))\n\n\n\n\n\n\n\n\n#\n\n\nDevices.Microwave.interdigit!\n \n \nFunction\n.\n\n\ninterdigit!{T}(c::Cell{T}, width, length, fingergap, fingeroffset, npairs::Integer,\n    skiplast, meta::Meta=GDSMeta(0,0))\n\n\n\n\n\nCreates interdigitated fingers, e.g. for a lumped element capacitor.\n\n\n\n\nwidth\n: finger width\n\n\nlength\n: finger length\n\n\nfingeroffset\n: x-offset at ends of fingers\n\n\nfingergap\n: gap between fingers\n\n\nnpairs\n: number of fingers\n\n\nskiplast\n: should we skip the last finger, leaving an odd number?\n\n\n\n\nsource\n\n\nSimple usage:\n\n\nfingers\n \n=\n \nCell\n(\nfingers\n,\n \nnm\n)\n\n\nwide\n,\n \nlength\n,\n \nfingergap\n,\n \nfingeroffset\n,\n \nnpairs\n,\n \nskiplast\n \n=\n \n1\n\u03bcm\n,\n \n20\n\u03bcm\n,\n \n1\n\u03bcm\n,\n \n3\n\u03bcm\n,\n \n5\n,\n \ntrue\n\n\ninterdigit!\n(\nfingers\n,\n \nwide\n,\n \nlength\n,\n \nfingergap\n,\n \nfingeroffset\n,\n \nnpairs\n,\n \nskiplast\n,\n \nGDSMeta\n(\n5\n))\n\n\n\n\n\n\n\n\nExample of how to make an interdigitated capacitor inline with a feedline:\n\n\nimport\n \nClipper\n\n\nc\n \n=\n \nCell\n(\nmain\n,\n \nnm\n)\n\n\np\n \n=\n \nPath\n(\n\u03bcm\n)\n\n\ntrace\n,\n \ngap\n \n=\n \n17\n\u03bcm\n,\n \n3\n\u03bcm\n\n\nstraight!\n(\np\n,\n \n50\n\u03bcm\n,\n \nPaths\n.\nCPW\n(\ntrace\n,\n \ngap\n))\n\n\nstraight!\n(\np\n,\n \n23\n\u03bcm\n,\n \nPaths\n.\nNoRender\n())\n\n\nstraight!\n(\np\n,\n \n50\n\u03bcm\n,\n \nPaths\n.\nCPW\n(\ntrace\n,\n \ngap\n))\n\n\nfingers\n \n=\n \nCell\n(\nfingers\n,\n \nnm\n)\n\n\nwide\n,\n \nlength\n,\n \nfingergap\n,\n \nfingeroffset\n,\n \nnpairs\n,\n \nskiplast\n \n=\n \n1\n\u03bcm\n,\n \n20\n\u03bcm\n,\n \n1\n\u03bcm\n,\n \n3\n\u03bcm\n,\n \n5\n,\n \ntrue\n\n\ninterdigit!\n(\nfingers\n,\n \nwide\n,\n \nlength\n,\n \nfingergap\n,\n \nfingeroffset\n,\n \nnpairs\n,\n \nskiplast\n,\n \nGDSMeta\n(\n5\n))\n\n\nfinger_mask\n \n=\n \nRectangle\n(\nwidth\n(\nbounds\n(\nfingers\n)),\n \nheight\n(\nbounds\n(\nfingers\n))\n+\n2\n*\ngap\n)\n \n-\n\n    \nPoint\n(\n0\n\u03bcm\n,\n \ngap\n)\n\n\ninverse_fingers\n \n=\n \nCell\n(\ninvfingers\n,\n \nnm\n)\n\n\nplgs\n \n=\n \nclip\n(\nClipper\n.\nClipTypeDifference\n,\n \n[\nfinger_mask\n],\n \npolygon\n.\n(\nelements\n(\nfingers\n)))\n\n\nfor\n \nplg\n \nin\n \nplgs\n\n    \nrender!\n(\ninverse_fingers\n,\n \nplg\n,\n \nGDSMeta\n(\n0\n))\n\n\nend\n\n\nattach!\n(\np\n,\n \nCellReference\n(\ninverse_fingers\n,\n \nPoint\n(\n0\n\u03bcm\n,\n \n-\nupperright\n(\nbounds\n(\nfingers\n))\n.\ny\n/\n2\n)),\n \n0\n\u03bcm\n,\n \ni\n=\n2\n)\n\n\nrender!\n(\nc\n,\n \np\n,\n \nGDSMeta\n(\n0\n))\n\n\n\n\n\n\n\n\n#\n\n\nDevices.Microwave.layerpixels!\n \n \nFunction\n.\n\n\nlayerpixels!{T}(c::Cell, layers::AbstractMatrix{Int}, pixsize)\n\n\n\n\n\nGiven \nlayers\n, a matrix of \nInt\n, make a bitmap of \nRectangle\n where the GDS-II layer corresponds to the number in the matrix. If the number is less than one, don't write the rectangle. All the rectangles get rendered into cell \nc\n. The rectangles are all in the first quadrant of the cell.\n\n\nsource\n\n\nExample:\n\n\nc\n \n=\n \nCell\n(\npix\n,\n \nnm\n)\n\n\nlayerpixels!\n(\nc\n,\n \n[\n1\n \n2\n \n3\n;\n \n-\n1\n \n2\n \n4\n],\n \n5\n\u03bcm\n)\n\n\n\n\n\n\n\n\n#\n\n\nDevices.Microwave.qubit!\n \n \nFunction\n.\n\n\nqubit!{T}(c::Cell{T}, trace, gap, claw_width, claw_length, claw_gap, ground_gap,\n    qubit_width, qubit_gap, meta::Meta)\n\n\n\n\n\nRenders the base metal for a capacitively-shunted charge qubit into cell \nc\n.\n\n\nsource\n\n\n#\n\n\nDevices.Microwave.qubit_claw!\n \n \nFunction\n.\n\n\nqubit_claw!{T}(c::Cell{T}, trace, gap, claw_width, claw_length, claw_gap, ground_gap,\n    qubit_width, qubit_gap, meta::Meta)\n\n\n\n\n\nRenders a \"claw\" into cell \nc\n suitable for attaching to the end of a resonator. One can wrap the claw around a capacitively-shunted charge qubit generated by \nqubit!\n for capacitive coupling between the qubit and resonator.\n\n\nsource\n\n\nExample:\n\n\nc\n \n=\n \nCell\n(\nmain\n,\n \nnm\n)\n\n\np\n \n=\n \nPath\n(\n\u03bcm\n)\n\n\nstraight!\n(\np\n,\n \n100\n\u03bcm\n,\n \nPaths\n.\nCPW\n(\n10\n\u03bcm\n,\n \n6\n\u03bcm\n))\n\n\nqbclaw\n \n=\n \nCell\n(\nqubit_claw\n,\n \nnm\n)\n\n\ntrace\n,\n \ngap\n,\n \nclaw_width\n,\n \nclaw_length\n,\n \nclaw_gap\n,\n \nground_gap\n,\n \nqubit_width\n,\n \nqubit_gap\n \n=\n\n    \n10\n\u03bcm\n,\n \n6\n\u03bcm\n,\n \n20\n\u03bcm\n,\n \n100\n\u03bcm\n,\n \n12\n\u03bcm\n,\n \n5\n\u03bcm\n,\n \n25\n\u03bcm\n,\n \n30\n\u03bcm\n\n\nqubit_claw!\n(\nqbclaw\n,\n \ntrace\n,\n \ngap\n,\n \nclaw_width\n,\n \nclaw_length\n,\n \nclaw_gap\n,\n \nground_gap\n,\n\n    \nqubit_width\n,\n \nqubit_gap\n,\n \nGDSMeta\n(\n1\n))\n\n\nqb\n \n=\n \nCell\n(\nqubit\n,\n \nnm\n)\n\n\nqubit_length\n,\n \nqubit_cap_bottom_gap\n,\n \ngap_between_leads_for_jjs\n,\n \nlead_width\n,\n \njunc_pad_spacing\n \n=\n\n    \n500\n\u03bcm\n,\n \n30\n\u03bcm\n,\n \n2\n\u03bcm\n,\n \n4\n\u03bcm\n,\n \n10\n\u03bcm\n\n\nqubit!\n(\nqb\n,\n \nqubit_length\n,\n \nqubit_width\n,\n \nqubit_gap\n,\n \nqubit_cap_bottom_gap\n,\n\n    \ngap_between_leads_for_jjs\n,\n \nlead_width\n,\n \njunc_pad_spacing\n,\n \nGDSMeta\n(\n2\n))\n\n\nattach!\n(\np\n,\n \nCellReference\n(\nqbclaw\n,\n \nPoint\n(\n0.0\n\u03bcm\n,\n \n0.0\n\u03bcm\n)),\n \n100\n\u03bcm\n)\n\n\nqref_offset\n \n=\n \nPoint\n(\nclaw_width\n \n+\n \nclaw_gap\n \n+\n \nground_gap\n \n+\n \nqubit_gap\n \n+\n \nqubit_length\n,\n \n0.0\n\u03bcm\n)\n\n\nattach!\n(\np\n,\n \nCellReference\n(\nqb\n,\n \nqref_offset\n,\n \nrot\n \n=\n \n90\n\u00b0\n),\n \n100\n\u03bcm\n)\n\n\nrender!\n(\nc\n,\n \np\n,\n \nGDSMeta\n(\n0\n))\n\n\n\n\n\n\n\n\n#\n\n\nDevices.Microwave.radialcut!\n \n \nFunction\n.\n\n\nradialcut\n!\n{\nT\n}\n(\nc\n::\nCell\n{\nT\n}\n,\n \nr\n,\n \n\u0398\n,\n \nh\n,\n \nmeta\n::\nMeta\n=\nGDSMeta\n(\n0\n,\n0\n);\n \nnarc\n::\nInt\n=\n197\n)\n\n\n\n\n\n\nRenders a radial cut (like a radial stub with no metal) into cell \nc\n. The polygon has to be subtracted from a ground plane.\n\n\nThe parameter \nh\n is made available in the method signature rather than \na\n because the focus of the arc (top of polygon) can easily centered in a waveguide. If it is desirable to control \na\n instead, use trig: \na/2 = h*tan(\u0398/2)\n.\n\n\nParameters as follows, where X marks the origin and (\nnothing above the origin is part of the resulting polygon\n):\n\n\n                       \u039b\n                      /\u2502\\\n                     / \u2502 \\\n                    /  |  \\\n              .    /   \u2502\u0398/2\\\n             .    /    \u2502----\\\n            /    /   h \u2502     \\\n           /    /      \u2502      \\\n          /    /       \u2502       \\\n         r    /        \u2502        \\\n        /    /         \u2502         \\\n       /    /----------X----------\\\n      /    /{--------- a ---------}\\\n     .    /                         \\\n    .    /                           \\\n        /                             \\\n       /                               \\\n      /                                 \\\n      --\u2510                             \u250c--\n        \u2514--\u2510                       \u250c--\u2518\n           \u2514--\u2510                 \u250c--\u2518\n              \u2514--\u2510           \u250c--\u2518\n                 \u2514-----------\u2518\n                 (circular arc)\n\n\n\n\n\nsource\n\n\nExample:\n\n\nc\n \n=\n \nCell\n(\nmain\n,\n \nnm\n)\n\n\nradialcut!\n(\nc\n,\n \n20\n\u03bcm\n,\n \n90\n\u00b0\n,\n \n5\n\u03bcm\n,\n \nGDSMeta\n(\n1\n))\n\n\n\n\n\n\n\n\n#\n\n\nDevices.Microwave.radialstub!\n \n \nFunction\n.\n\n\nradialstub\n!\n{\nT\n}\n(\nc\n::\nCell\n{\nT\n}\n,\n \nr\n,\n \n\u0398\n,\n \nh\n,\n \nt\n,\n \nmeta\n::\nMeta\n=\nGDSMeta\n(\n0\n,\n0\n);\n \nnarc\n::\nInt\n=\n197\n)\n\n\n\n\n\n\nSee also the documentation for \nradialcut!\n.\n\n\nReturns a polygon for a radial stub. The polygon has to be subtracted from a ground plane, and will leave a defect in the ground plane of uniform width \nt\n that outlines the (metallic) radial stub. \nr\n refers to the radius of the actual stub, not the radius of the circular arc bounding the ground plane defect. Likewise \nh\n has an analogous meaning to that in \nradialcut!\n except it refers here to the radial stub, not the ground plane defect.\n\n\nsource\n\n\nExample:\n\n\nc\n \n=\n \nCell\n(\nmain\n,\n \nnm\n)\n\n\nradialstub!\n(\nc\n,\n \n20\n\u03bcm\n,\n \n90\n\u00b0\n,\n \n5\n\u03bcm\n,\n \n1\n\u03bcm\n,\n \nGDSMeta\n(\n1\n))\n\n\n\n\n\n\n\n\n\n\nLCDFonts\n\n\nLCDFonts allows the user with \nlcdstring!\n to render a string which is displayed in a cell with a per character resolution of 5x10. Three functions \ncharacters_demo\n, \nscripted_demo\n, \nreferenced_characters_demo\n are exported for demonstration but also serves as a test of the functionality.\n\n\n#\n\n\nDevices.LCDFonts.lcdstring!\n \n \nFunction\n.\n\n\nlcdstring\n!(\nstring_cell\n::\nCell\n,\n \nstr\n::\nString\n,\n \npixelsize\n,\n \npixelspacing\n;\n \nscripting\n \n=\n \nfalse\n,\n \nlinelimit\n \n=\n \n2\n^\n32\n,\n \nmeta\n::\nMeta\n=\nGDSMeta\n(\n0\n,\n0\n))\n\n\n\n\n\n\nRenders the string \nstr\n to cell \nc\n in a pixelated font format.\n\n\n\n\npixelsize\n: dimension for the width/height of each pixel\n\n\npixelspacing\n: dimension for the spacing between adjacent pixels\n\n\nscripting\n: boolean parameter for allocating special characters \n^\n, \n_\n, \n{\n, and \n}\n for superscripting and subscripting. Follows the same usage as LaTex.\n\n\nlinelimit\n: sets the maximum number of characters per line and continues on a new line if \nstr\n is longer than \nlinelimit\n\n\nverbose\n: prints out information about the character dictionary\n\n\n\n\nsource\n\n\n#\n\n\nDevices.LCDFonts.characters_demo\n \n \nFunction\n.\n\n\ncharacters_demo(save_path = joinpath(homedir(),\nDesktop\n,\ncharacters.gds\n), flatten = false)\n\n\n\n\n\nDemo script for demonstrating the avalible characters in \nlcdstring!()\n and the \nlinelimit\n parameter in use. \nflatten\n can flatten the cells before saving (for SVG output).\n\n\nsource\n\n\n#\n\n\nDevices.LCDFonts.scripted_demo\n \n \nFunction\n.\n\n\nscripted_demo(save_path = joinpath(homedir(),\nDesktop\n,\nscripted.gds\n), flatten = false)\n\n\n\n\n\nDemo script for demonstrating the use of the \nscripting\n parameter in \nlcdstring!()\n. \nflatten\n can flatten the cells before saving (for SVG output).\n\n\nsource\n\n\n#\n\n\nDevices.LCDFonts.referenced_characters_demo\n \n \nFunction\n.\n\n\ncharacters_demo(save_path = joinpath(homedir(),\nDesktop\n,\nreferenced_characters.gds\n))\n\n\n\n\n\nDemo script for demonstrating the memory saving ability of keeping CellReferences for previously used characters in \nlcdstring!()\n.\n\n\nsource\n\n\n\n\nInline demonstrations\n\n\ncharacters_demo\n(\npath_to_output_gds\n,\n \ntrue\n)\n\n\n\n\n\n\n852799\n\n\n\n\n\n\n\nscripted_demo\n(\npath_to_output_gds\n,\n \ntrue\n);\n\n\n\n\n\n\n47312", 
            "title": "Compound shapes"
        }, 
        {
            "location": "/shapes/#lcdfonts", 
            "text": "LCDFonts allows the user with  lcdstring!  to render a string which is displayed in a cell with a per character resolution of 5x10. Three functions  characters_demo ,  scripted_demo ,  referenced_characters_demo  are exported for demonstration but also serves as a test of the functionality.  #  Devices.LCDFonts.lcdstring!     Function .  lcdstring !( string_cell :: Cell ,   str :: String ,   pixelsize ,   pixelspacing ;   scripting   =   false ,   linelimit   =   2 ^ 32 ,   meta :: Meta = GDSMeta ( 0 , 0 ))   Renders the string  str  to cell  c  in a pixelated font format.   pixelsize : dimension for the width/height of each pixel  pixelspacing : dimension for the spacing between adjacent pixels  scripting : boolean parameter for allocating special characters  ^ ,  _ ,  { , and  }  for superscripting and subscripting. Follows the same usage as LaTex.  linelimit : sets the maximum number of characters per line and continues on a new line if  str  is longer than  linelimit  verbose : prints out information about the character dictionary   source  #  Devices.LCDFonts.characters_demo     Function .  characters_demo(save_path = joinpath(homedir(), Desktop , characters.gds ), flatten = false)  Demo script for demonstrating the avalible characters in  lcdstring!()  and the  linelimit  parameter in use.  flatten  can flatten the cells before saving (for SVG output).  source  #  Devices.LCDFonts.scripted_demo     Function .  scripted_demo(save_path = joinpath(homedir(), Desktop , scripted.gds ), flatten = false)  Demo script for demonstrating the use of the  scripting  parameter in  lcdstring!() .  flatten  can flatten the cells before saving (for SVG output).  source  #  Devices.LCDFonts.referenced_characters_demo     Function .  characters_demo(save_path = joinpath(homedir(), Desktop , referenced_characters.gds ))  Demo script for demonstrating the memory saving ability of keeping CellReferences for previously used characters in  lcdstring!() .  source", 
            "title": "LCDFonts"
        }, 
        {
            "location": "/shapes/#inline-demonstrations", 
            "text": "characters_demo ( path_to_output_gds ,   true )   852799   scripted_demo ( path_to_output_gds ,   true );   47312", 
            "title": "Inline demonstrations"
        }, 
        {
            "location": "/render/", 
            "text": "Render methods\n\n\n#\n\n\nDevices.render!\n \n \nFunction\n.\n\n\nrender!(c::Cell, r::Rectangle, meta::Meta=GDSMeta()) = render!(c, p, Rectangles.Plain(), meta)\nrender!(c::Cell, r::Rectangle,  ::Rectangles.Plain, meta::Meta)\nrender!(c::Cell, r::Rectangle, s::Rectangles.Rounded, meta::Meta)\nrender!(c::Cell, r::Rectangle, s::Rectangles.Undercut, meta::Meta)\n\n\n\n\n\nRender a rectangle \nr\n to cell \nc\n, defaulting to plain styling.\n\n\nsource\n\n\nrender!(c::Cell, p::Polygon, meta::Meta=GDSMeta()) = render!(c, p, Polygons.Plain(), meta)\nrender!(c::Cell, r::Polygon, s::Polygons.Style, meta::Meta)\n\n\n\n\n\nRender a polygon \nr\n to cell \nc\n, defaulting to plain styling. Currently there is no other Polygon rendering style implemented.\n\n\nsource\n\n\nrender\n!\n{\nT\n}\n(\nc\n::\nCell\n,\n \np\n::\nPath\n{\nT\n}\n,\n \nmeta\n::\nMeta\n=\nGDSMeta\n();\n \nkwargs\n...)\n\n\n\n\n\n\nRender a path \np\n to a cell \nc\n.\n\n\nsource\n\n\nrender\n!(\nc\n::\nCell\n,\n \nsegment\n::\nPaths\n.\nSegment\n,\n \ns\n::\nPaths\n.\nDecoratedStyle\n,\n \nmeta\n::\nMeta\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a \nsegment\n with decorated style \ns\n to cell \nc\n. Cell references held by the decorated style will have their fields modified by this method, which is why they are shallow copied in the \nPaths.attach!\n function.\n\n\nThis method draws the decorations before the path itself is drawn.\n\n\nsource\n\n\n\n\nRectangle rendering styles\n\n\n#\n\n\nDevices.Rectangles.Plain\n \n \nType\n.\n\n\nstruct Plain{T} \n: Rectangles.Style{T}\n    meta::T\nend\n\n\n\n\n\nPlain rectangle style. Use this if you are fond for the simpler times when rectangles were just rectangles.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Rounded\n \n \nType\n.\n\n\nstruct Rounded{S\n:Coordinate,T} \n: Rectangles.Style{T}\n    r::S\n    meta::T\nend\n\n\n\n\n\nRounded rectangle style. All corners are rounded off with a given radius \nr\n. The bounding box of the unstyled rectangle should remain unaffected.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Undercut\n \n \nType\n.\n\n\nstruct Undercut{S\n:Coordinate,T} \n: Rectangles.Style{T}\n    ucl::S\n    uct::S\n    ucr::S\n    ucb::S\n    meta::T\n    undercut_meta::T\nend\n\n\n\n\n\nUndercut rectangles. In each direction around a rectangle (left, top, right, bottom) an undercut is rendered on .\n\n\nsource\n\n\n\n\nPolygon rendering styles\n\n\n#\n\n\nDevices.Polygons.Plain\n \n \nType\n.\n\n\nstruct Plain{T} \n: Polygons.Style{T}\n    meta::T\nend\n\n\n\n\n\nPlain polygon style.\n\n\nsource\n\n\n\n\nRendering arbitrary paths\n\n\nA \nSegment\n and \nStyle\n together define one or more closed curves in the plane. The job of rendering is to approximate these curves by closed polygons. To enable rendering of styles along generic paths in the plane, an adaptive algorithm is used when no other method is available:\n\n\n#\n\n\nDevices.adapted_grid\n \n \nFunction\n.\n\n\nadapted_grid(f, anchors;\n    max_recursions::Real = 7, max_change = 5\u00b0, rand_factor::Real = 0.05,\n    grid_step = 1.0\u03bcm)\n\n\n\n\n\nComputes a resampled \ngrid\n given anchor points so that \nf.(grid)\n is sufficiently smooth. The method used is to create an initial grid around the anchor points and refine intervals. When an interval becomes \"straight enough\" it is no longer divided. Adapted from a contribution to PlotUtils.jl from Kristoffer Carlsson.\n\n\n\n\nmax_recursions\n: how many times each interval is allowed to be refined.\n\n\nmax_change\n: specifies acceptable change between evaluations of \nf\n on subsequent grid points, as estimated by the derivative times the distance between grid points. Typically, \nf\n is the angle of a path in the plane, so this is often an angle threshold. This condition is approximately valid in the end result, but may be weakly violated. This condition may be grossly violated if \nmax_recursions\n is too low.\n\n\nrand_factor\n: between anchor points, \nadapted_grid\n will wiggle initial grid points a bit to prevent aliasing. The wiggling is sampled uniformly from the interval: \n[-rand_factor, rand_factor]\n, times the distance between three grid points (e.g. \ni+1\n and \ni-1\n). A random number generator is given a fixed seed every time \nadapted_grid\n is called, so the rendered results are deterministic.\n\n\ngrid_step\n: Step size for initial grid points. If you set this to be larger than the maximum anchor point, then the lowest resolution consistent with \nmax_change\n is used (unless \nf\n has some fast variations that the algorithm might miss).\n\n\n\n\nsource\n\n\nIn some cases, custom rendering methods are implemented when it would improve performance for simple structures or when special attention is required. The rendering methods can specialize on either the \nSegment\n or \nStyle\n types, or both.", 
            "title": "Rendering"
        }, 
        {
            "location": "/render/#render-methods", 
            "text": "#  Devices.render!     Function .  render!(c::Cell, r::Rectangle, meta::Meta=GDSMeta()) = render!(c, p, Rectangles.Plain(), meta)\nrender!(c::Cell, r::Rectangle,  ::Rectangles.Plain, meta::Meta)\nrender!(c::Cell, r::Rectangle, s::Rectangles.Rounded, meta::Meta)\nrender!(c::Cell, r::Rectangle, s::Rectangles.Undercut, meta::Meta)  Render a rectangle  r  to cell  c , defaulting to plain styling.  source  render!(c::Cell, p::Polygon, meta::Meta=GDSMeta()) = render!(c, p, Polygons.Plain(), meta)\nrender!(c::Cell, r::Polygon, s::Polygons.Style, meta::Meta)  Render a polygon  r  to cell  c , defaulting to plain styling. Currently there is no other Polygon rendering style implemented.  source  render ! { T } ( c :: Cell ,   p :: Path { T } ,   meta :: Meta = GDSMeta ();   kwargs ...)   Render a path  p  to a cell  c .  source  render !( c :: Cell ,   segment :: Paths . Segment ,   s :: Paths . DecoratedStyle ,   meta :: Meta ;   kwargs ...)   Render a  segment  with decorated style  s  to cell  c . Cell references held by the decorated style will have their fields modified by this method, which is why they are shallow copied in the  Paths.attach!  function.  This method draws the decorations before the path itself is drawn.  source", 
            "title": "Render methods"
        }, 
        {
            "location": "/render/#rectangle-rendering-styles", 
            "text": "#  Devices.Rectangles.Plain     Type .  struct Plain{T}  : Rectangles.Style{T}\n    meta::T\nend  Plain rectangle style. Use this if you are fond for the simpler times when rectangles were just rectangles.  source  #  Devices.Rectangles.Rounded     Type .  struct Rounded{S :Coordinate,T}  : Rectangles.Style{T}\n    r::S\n    meta::T\nend  Rounded rectangle style. All corners are rounded off with a given radius  r . The bounding box of the unstyled rectangle should remain unaffected.  source  #  Devices.Rectangles.Undercut     Type .  struct Undercut{S :Coordinate,T}  : Rectangles.Style{T}\n    ucl::S\n    uct::S\n    ucr::S\n    ucb::S\n    meta::T\n    undercut_meta::T\nend  Undercut rectangles. In each direction around a rectangle (left, top, right, bottom) an undercut is rendered on .  source", 
            "title": "Rectangle rendering styles"
        }, 
        {
            "location": "/render/#polygon-rendering-styles", 
            "text": "#  Devices.Polygons.Plain     Type .  struct Plain{T}  : Polygons.Style{T}\n    meta::T\nend  Plain polygon style.  source", 
            "title": "Polygon rendering styles"
        }, 
        {
            "location": "/render/#rendering-arbitrary-paths", 
            "text": "A  Segment  and  Style  together define one or more closed curves in the plane. The job of rendering is to approximate these curves by closed polygons. To enable rendering of styles along generic paths in the plane, an adaptive algorithm is used when no other method is available:  #  Devices.adapted_grid     Function .  adapted_grid(f, anchors;\n    max_recursions::Real = 7, max_change = 5\u00b0, rand_factor::Real = 0.05,\n    grid_step = 1.0\u03bcm)  Computes a resampled  grid  given anchor points so that  f.(grid)  is sufficiently smooth. The method used is to create an initial grid around the anchor points and refine intervals. When an interval becomes \"straight enough\" it is no longer divided. Adapted from a contribution to PlotUtils.jl from Kristoffer Carlsson.   max_recursions : how many times each interval is allowed to be refined.  max_change : specifies acceptable change between evaluations of  f  on subsequent grid points, as estimated by the derivative times the distance between grid points. Typically,  f  is the angle of a path in the plane, so this is often an angle threshold. This condition is approximately valid in the end result, but may be weakly violated. This condition may be grossly violated if  max_recursions  is too low.  rand_factor : between anchor points,  adapted_grid  will wiggle initial grid points a bit to prevent aliasing. The wiggling is sampled uniformly from the interval:  [-rand_factor, rand_factor] , times the distance between three grid points (e.g.  i+1  and  i-1 ). A random number generator is given a fixed seed every time  adapted_grid  is called, so the rendered results are deterministic.  grid_step : Step size for initial grid points. If you set this to be larger than the maximum anchor point, then the lowest resolution consistent with  max_change  is used (unless  f  has some fast variations that the algorithm might miss).   source  In some cases, custom rendering methods are implemented when it would improve performance for simple structures or when special attention is required. The rendering methods can specialize on either the  Segment  or  Style  types, or both.", 
            "title": "Rendering arbitrary paths"
        }, 
        {
            "location": "/fileio/", 
            "text": "This package can load/save patterns in the GDS-II format for use with e-beam lithography systems. In the future it may be useful to implement machine-specific pattern formats to force fracturing or dosing in an explicit manner.\n\n\nWe also provide an experimental option to export to the SVG vector graphics format. This enables patterns to be inspected in web browsers or used in presentations, for example.\n\n\n\n\nSaving patterns\n\n\nTo save a pattern in any format, make sure you are \nusing\n \nFileIO\n.\n\n\n#\n\n\nFileIO.save\n \n \nMethod\n.\n\n\nsave\n(\n::\nUnion\n{\nAbstractString,IO\n}\n,\n \ncell0\n::\nCell\n{\nT\n}\n,\n \ncell\n::\nCell\n...)\n\n\nsave\n(\nf\n::\nFile\n{\nformat\nGDS\n}\n,\n \ncell0\n::\nCell\n,\n \ncell\n::\nCell\n...;\n\n    \nname\n=\nGDSIILIB\n,\n \nuserunit\n=\n1\n\u03bc\nm\n,\n \nmodify\n=\nnow\n(),\n \nacc\n=\nnow\n(),\n\n    \nverbose\n=\nfalse\n)\n\n\n\n\n\n\nThis bottom method is implicitly called when you use the convenient syntax of the top method: \nsave(\"/path/to/my.gds\", cells_i_want_to_save...)\n\n\nKeyword arguments include:\n\n\n\n\nname\n: used for the internal library name of the GDS-II file and probably inconsequential for modern workflows.\n\n\nuserunit\n: sets what 1.0 corresponds to when viewing this file in graphical GDS editors with inferior unit support.\n\n\nmodify\n: date of last modification.\n\n\nacc\n: date of last accession. It would be unusual to have this differ from \nnow()\n.\n\n\nverbose\n: monitor the output of \ntraverse!\n and \norder!\n to see if something funny is happening while saving.\n\n\n\n\nsource\n\n\n#\n\n\nFileIO.save\n \n \nMethod\n.\n\n\nsave\n(\n::\nUnion\n{\nAbstractString,IO\n}\n,\n \nc0\n::\nCell\n;\n \noptions\n...)\n\n\nsave\n(\nf\n::\nFile\n{\nformat\nSVG\n}\n,\n \nc0\n::\nCell\n;\n \noptions\n...)\n\n\n\n\n\n\nThis bottom method is implicitly called when you use the convenient syntax of the top method: \nsave(\"/path/to/my.gds\", cell_i_want_to_save)\n\n\nPossible keyword arguments include:\n\n\n\n\nwidth\n: Specifies the width parameter of the SVG tag. Defaults to the width of the cell bounding box (stripped of units).\n\n\nheight\n: Specifies the height parameter of the SVG tag. Defaults to the height of the cell bounding box (stripped of units).\n\n\nlayercolors\n: Should be a dictionary with \nInt\n keys for layers and color strings as values. By color strings we mean \"#ff0000\", \"red\", \"rgb(255,0,0)\", etc.\n\n\n\n\nsource\n\n\n\n\nLoading patterns\n\n\nTo load a pattern in any format, make sure you are \nusing\n \nFileIO\n.\n\n\n#\n\n\nFileIO.load\n \n \nMethod\n.\n\n\nload\n(\nf\n::\nFile\n{\nformat\nGDS\n}\n;\n \nverbose\n::\nBool\n=\nfalse\n,\n \nnounits\n::\nBool\n=\nfalse\n)\n\n\n\n\n\n\nA dictionary of top-level cells (\nCell\n objects) found in the GDS-II file is returned. The dictionary keys are the cell names. The other cells in the GDS-II file are retained by \nCellReference\n or \nCellArray\n objects held by the top-level cells. Currently, cell references and arrays are not implemented.\n\n\nThe FileIO package recognizes files based on \"magic bytes\" at the start of the file. To permit any version of GDS-II file to be read, we consider the magic bytes to be the GDS HEADER tag (\n0x0002\n), preceded by the number of bytes in total (\n0x0006\n) for the entire HEADER record. The last well-documented version of GDS-II is v6.0.0, encoded as \n0x0258 == 600\n. LayoutEditor appears to save a version 7 as \n0x0007\n, which as far as I can tell is unofficial, and probably just permits more layers than 64, or extra characters in cell names, etc.\n\n\nIf the database scale is \n1\u03bcm\n, \n1nm\n, or \n1pm\n, then the corresponding unit is used for the resulting imported cells. Otherwise, an \"anonymous unit\" is used that will display as \nu\"2.4\u03bcm\"\n if the database scale is 2.4\u03bcm, say.\n\n\nWarnings are thrown if the GDS-II file does not begin with a BGNLIB record following the HEADER record, but loading will proceed.\n\n\nEncountering an ENDLIB record will discard the remainder of the GDS-II file without warning. If no ENDLIB record is present, a warning will be thrown.\n\n\nThe content of some records are currently discarded (mainly the more obscure GDS-II record types, but also BGNLIB and LIBNAME).\n\n\nIf \nnounits\n is true, \nCell{Float64}\n objects will be returned, where 1.0 corresponds to one micron.\n\n\nsource\n\n\n#\n\n\nFileIO.load\n \n \nMethod\n.\n\n\nload(f::File{format\nSVG\n})\n\n\n\n\n\nNot yet implemented.\n\n\nsource", 
            "title": "File formats"
        }, 
        {
            "location": "/fileio/#saving-patterns", 
            "text": "To save a pattern in any format, make sure you are  using   FileIO .  #  FileIO.save     Method .  save ( :: Union { AbstractString,IO } ,   cell0 :: Cell { T } ,   cell :: Cell ...)  save ( f :: File { format GDS } ,   cell0 :: Cell ,   cell :: Cell ...; \n     name = GDSIILIB ,   userunit = 1 \u03bc m ,   modify = now (),   acc = now (), \n     verbose = false )   This bottom method is implicitly called when you use the convenient syntax of the top method:  save(\"/path/to/my.gds\", cells_i_want_to_save...)  Keyword arguments include:   name : used for the internal library name of the GDS-II file and probably inconsequential for modern workflows.  userunit : sets what 1.0 corresponds to when viewing this file in graphical GDS editors with inferior unit support.  modify : date of last modification.  acc : date of last accession. It would be unusual to have this differ from  now() .  verbose : monitor the output of  traverse!  and  order!  to see if something funny is happening while saving.   source  #  FileIO.save     Method .  save ( :: Union { AbstractString,IO } ,   c0 :: Cell ;   options ...)  save ( f :: File { format SVG } ,   c0 :: Cell ;   options ...)   This bottom method is implicitly called when you use the convenient syntax of the top method:  save(\"/path/to/my.gds\", cell_i_want_to_save)  Possible keyword arguments include:   width : Specifies the width parameter of the SVG tag. Defaults to the width of the cell bounding box (stripped of units).  height : Specifies the height parameter of the SVG tag. Defaults to the height of the cell bounding box (stripped of units).  layercolors : Should be a dictionary with  Int  keys for layers and color strings as values. By color strings we mean \"#ff0000\", \"red\", \"rgb(255,0,0)\", etc.   source", 
            "title": "Saving patterns"
        }, 
        {
            "location": "/fileio/#loading-patterns", 
            "text": "To load a pattern in any format, make sure you are  using   FileIO .  #  FileIO.load     Method .  load ( f :: File { format GDS } ;   verbose :: Bool = false ,   nounits :: Bool = false )   A dictionary of top-level cells ( Cell  objects) found in the GDS-II file is returned. The dictionary keys are the cell names. The other cells in the GDS-II file are retained by  CellReference  or  CellArray  objects held by the top-level cells. Currently, cell references and arrays are not implemented.  The FileIO package recognizes files based on \"magic bytes\" at the start of the file. To permit any version of GDS-II file to be read, we consider the magic bytes to be the GDS HEADER tag ( 0x0002 ), preceded by the number of bytes in total ( 0x0006 ) for the entire HEADER record. The last well-documented version of GDS-II is v6.0.0, encoded as  0x0258 == 600 . LayoutEditor appears to save a version 7 as  0x0007 , which as far as I can tell is unofficial, and probably just permits more layers than 64, or extra characters in cell names, etc.  If the database scale is  1\u03bcm ,  1nm , or  1pm , then the corresponding unit is used for the resulting imported cells. Otherwise, an \"anonymous unit\" is used that will display as  u\"2.4\u03bcm\"  if the database scale is 2.4\u03bcm, say.  Warnings are thrown if the GDS-II file does not begin with a BGNLIB record following the HEADER record, but loading will proceed.  Encountering an ENDLIB record will discard the remainder of the GDS-II file without warning. If no ENDLIB record is present, a warning will be thrown.  The content of some records are currently discarded (mainly the more obscure GDS-II record types, but also BGNLIB and LIBNAME).  If  nounits  is true,  Cell{Float64}  objects will be returned, where 1.0 corresponds to one micron.  source  #  FileIO.load     Method .  load(f::File{format SVG })  Not yet implemented.  source", 
            "title": "Loading patterns"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The Devices.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nA modified version of \nadaptive_grid\n was originally from PlotUtils.jl, an MIT \"Expat\" licensed Julia package by Tom Breloff and contributors (notably Kristoffer Carlsson).\n\n\nCadence Design Systems, Inc. holds the rights to the GDS-II format. The specification has been described with permission in the SPIE Handbook of Microlithography, Micromachining and Microfabrication, vol. 1 (accessible \nhere\n as of April 17, 2017).", 
            "title": "License"
        }
    ]
}